<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Add Copy Button to Code Blocks in Hexo</title>
    <url>/2025/03/26/Add-Copy-Button-to-Code-Blocks-in-Hexo/</url>
    <content><![CDATA[<h1 id="Hexo-为代码块添加复制功能按钮"><a href="#Hexo-为代码块添加复制功能按钮" class="headerlink" title="Hexo 为代码块添加复制功能按钮"></a>Hexo 为代码块添加复制功能按钮</h1><p>本文详细记录如何在 Hexo 中为代码块添加一个 “复制” 按钮，实现一键复制代码功能。</p>
<hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Blog-Learning.git">https://github.com/EvannZhongg/Blog-Learning.git</a></p>
<hr>
<h2 id="结构要求与适配说明"><a href="#结构要求与适配说明" class="headerlink" title="结构要求与适配说明"></a>结构要求与适配说明</h2><p>本复制功能脚本适用于以下结构的代码块：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;gutter&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;code&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>...<span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是 Hexo 中多数主题（包括 Chic、NexT、Butterfly 等）默认的代码块渲染结构。</p>
<h3 id="如何检查自己主题的结构是否符合？"><a href="#如何检查自己主题的结构是否符合？" class="headerlink" title="如何检查自己主题的结构是否符合？"></a>如何检查自己主题的结构是否符合？</h3><ol>
<li>启动本地博客：<code>hexo s</code></li>
<li>在浏览器中打开博客页面</li>
<li>右键代码块 → 点击“检查”</li>
<li>查看代码块的外层 HTML 标签是否为 <code>figure.highlight</code> </li>
<li>或者直接在浏览器中点击 <code>F12</code> ，在 <code>Elements</code> 中直接搜索是否含有 <code>figure.highlight</code></li>
</ol>
<hr>
<h2 id="1-创建-JavaScript-脚本文件"><a href="#1-创建-JavaScript-脚本文件" class="headerlink" title="1. 创建 JavaScript 脚本文件"></a><strong>1. 创建 JavaScript 脚本文件</strong></h2><p>在 Hexo 博客项目的根目录下创建 JS 脚本文件 <code>code-copy.js</code> ,如果没有js文件夹则自己创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source/js/code-copy.js</span><br></pre></td></tr></table></figure>

<p>并填入以下完整内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;figure.highlight&#x27;</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">figure</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (figure.<span class="title function_">querySelector</span>(<span class="string">&#x27;.copy-btn&#x27;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> copyBtn = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">    copyBtn.<span class="property">className</span> = <span class="string">&#x27;copy-btn&#x27;</span>;</span><br><span class="line">    copyBtn.<span class="property">title</span> = <span class="string">&#x27;复制&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缩小后的复制图标（14*15）</span></span><br><span class="line">    <span class="keyword">const</span> copyIcon = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;14&quot; width=&quot;15&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;white&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;path d=&quot;M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 18H8V7h11v16z&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/svg&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功后显示的勾（14*15）</span></span><br><span class="line">    <span class="keyword">const</span> checkIcon = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;14&quot; width=&quot;15&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;#00cc66&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;path d=&quot;M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/svg&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    copyBtn.<span class="property">innerHTML</span> = copyIcon;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按钮样式（浅灰底、缩小）</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">assign</span>(copyBtn.<span class="property">style</span>, &#123;</span><br><span class="line">      <span class="attr">position</span>: <span class="string">&#x27;absolute&#x27;</span>,</span><br><span class="line">      <span class="attr">top</span>: <span class="string">&#x27;8px&#x27;</span>,</span><br><span class="line">      <span class="attr">right</span>: <span class="string">&#x27;8px&#x27;</span>,</span><br><span class="line">      <span class="attr">padding</span>: <span class="string">&#x27;4px&#x27;</span>,</span><br><span class="line">      <span class="attr">background</span>: <span class="string">&#x27;#aaa&#x27;</span>, </span><br><span class="line">      <span class="attr">border</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">      <span class="attr">borderRadius</span>: <span class="string">&#x27;4px&#x27;</span>,</span><br><span class="line">      <span class="attr">cursor</span>: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">      <span class="attr">opacity</span>: <span class="string">&#x27;0.85&#x27;</span>,</span><br><span class="line">      <span class="attr">zIndex</span>: <span class="number">1000</span>,</span><br><span class="line">      <span class="attr">transition</span>: <span class="string">&#x27;opacity 0.2s ease&#x27;</span>,</span><br><span class="line">      <span class="attr">boxShadow</span>: <span class="string">&#x27;0 1px 3px rgba(0, 0, 0, 0.15)&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    copyBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function">() =&gt;</span> copyBtn.<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    copyBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function">() =&gt;</span> copyBtn.<span class="property">style</span>.<span class="property">opacity</span> = <span class="string">&#x27;0.85&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    copyBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> code = figure.<span class="title function_">querySelector</span>(<span class="string">&#x27;td.code&#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> text = code ? code.<span class="property">innerText</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">      navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(text).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        copyBtn.<span class="property">innerHTML</span> = checkIcon;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          copyBtn.<span class="property">innerHTML</span> = copyIcon;</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    figure.<span class="property">style</span>.<span class="property">position</span> = <span class="string">&#x27;relative&#x27;</span>;</span><br><span class="line">    figure.<span class="title function_">appendChild</span>(copyBtn);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-在页面底部引入-JS-文件"><a href="#2-在页面底部引入-JS-文件" class="headerlink" title="2. 在页面底部引入 JS 文件"></a><strong>2. 在页面底部引入 JS 文件</strong></h2><p>打开文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes/hexo-theme-Chic/layout/_partial/footer.ejs</span><br></pre></td></tr></table></figure>

<p>在 <code>&lt;/footer&gt;</code> 标签之后添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/code-copy.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样可以确保复制按钮脚本在页面加载完毕后自动运行。</p>
<hr>
<h2 id="3-生成并本地预览效果"><a href="#3-生成并本地预览效果" class="headerlink" title="3. 生成并本地预览效果"></a><strong>3. 生成并本地预览效果</strong></h2><p>运行以下命令，重新生成并启动本地预览：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后访问 <code>http://localhost:4000</code>，查看任意一段代码块，右上角应出现复制图标按钮。</p>
<hr>
<p>修改后的相关完整代码可以在文章开头的项目地址中获取</p>
<hr>
<p>该项目代码基于 <a href="https://github.com/hexojs/hexo.git">Hexo</a> 和 <a href="https://github.com/Siricee/hexo-theme-Chic.git">hexo-theme-Chic</a> 。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Convert PDF Tables to Readable Text</title>
    <url>/2025/03/28/Convert-PDF-Tables-to-Readable-Text/</url>
    <content><![CDATA[<h1 id="PDF-表格提取转为纯文本结构数据"><a href="#PDF-表格提取转为纯文本结构数据" class="headerlink" title="PDF 表格提取转为纯文本结构数据"></a>PDF 表格提取转为纯文本结构数据</h1><p>本文详细记录了如何使用读光的  Cycle-CenterNet 有线表格识别模型进行表格结构识别，以及 PaddleOCR 进行文本识别，将 PDF 中的表格图像转为大模型可以理解的表格结构。</p>
<hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Table_Extraction.git">https://github.com/EvannZhongg/Table_Extraction.git</a></p>
<hr>
<h2 id="项目概览"><a href="#项目概览" class="headerlink" title="项目概览"></a><strong>项目概览</strong></h2><p>本项目的主要目标是将 PDF 文件中存在的表格，作为图片提取参数信息，尤其是结构化表格。整个流程分为两个阶段：</p>
<ol>
<li><strong>表格结构识别</strong> —— 使用 Cycle-CenterNet 模型识别表格中每个单元格的位置（多边形坐标）。</li>
<li><strong>OCR 文本识别</strong> —— 使用 PaddleOCR 识别图像中所有文字及其位置坐标。</li>
</ol>
<hr>
<h2 id="环境与设置"><a href="#环境与设置" class="headerlink" title="环境与设置"></a><strong>环境与设置</strong></h2><h3 id="1-表格识别模型配置"><a href="#1-表格识别模型配置" class="headerlink" title="1. 表格识别模型配置"></a><strong>1. 表格识别模型配置</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git <span class="built_in">clone</span> https://www.modelscope.cn/iic/cv_dla34_table-structure-recognition_cycle-centernet.git</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model_path = <span class="string">&quot;your_absolute_path_to_cv_dla34_table-structure-recognition_cycle-centernet&quot;</span></span><br></pre></td></tr></table></figure>
<p>建议自定义路径使用绝对路径</p>
<p>例如：<code>model_path = &quot;D:/Table_Extraction/cv_dla34_table-structure-recognition_cycle-centernet&quot;</code></p>
<h3 id="2-PaddleOCR-配置"><a href="#2-PaddleOCR-配置" class="headerlink" title="2. PaddleOCR 配置"></a><strong>2. PaddleOCR 配置</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ocr = PaddleOCR(</span><br><span class="line">    use_gpu=<span class="literal">True</span>,</span><br><span class="line">    lang=<span class="string">&#x27;ch&#x27;</span>,</span><br><span class="line">    det_model_dir=<span class="string">&#x27;your_absolute_path_to_ch_PP-OCRv4_det_infer&#x27;</span>,</span><br><span class="line">    rec_model_dir=<span class="string">&#x27;your_absolute_path_to_ch_PP-OCRv4_rec_infer&#x27;</span>,</span><br><span class="line">    cls_model_dir=<span class="string">&#x27;your_absolute_path_to_ch_ppocr_mobile_v2.0_cls_infer&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>建议自定义路径使用绝对路径</p>
<p>例如： <code>det_model_dir=&#39;D:/Table_Extraction/PaddleOCR/models/ch_PP-OCRv4_det_infer/&#39;</code></p>
<hr>
<h2 id="核心函数详解"><a href="#核心函数详解" class="headerlink" title="核心函数详解"></a><strong>核心函数详解</strong></h2><h3 id="1-函数-calculate-iot-cell-text"><a href="#1-函数-calculate-iot-cell-text" class="headerlink" title="1. 函数 calculate_iot(cell, text)"></a><strong>1. 函数 <code>calculate_iot(cell, text)</code></strong></h3><p><strong>功能</strong>：计算 OCR 文本框与表格单元格的交并比（IoT, Intersection over Text）。</p>
<p><strong>原理说明</strong>：</p>
<ul>
<li>利用两组矩形坐标，计算它们重叠区域的面积。</li>
<li>然后用重叠面积 &#x2F; 文本框面积作为 IoT 值。</li>
<li>若值越大，表示文本越“贴合”单元格。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_iot</span>(<span class="params">cell, text</span>):</span><br><span class="line">    intersection_x1 = <span class="built_in">max</span>(cell[<span class="number">0</span>], text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">0</span>])</span><br><span class="line">    intersection_y1 = <span class="built_in">max</span>(cell[<span class="number">1</span>], text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">1</span>])</span><br><span class="line">    intersection_x2 = <span class="built_in">min</span>(cell[<span class="number">2</span>], text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">2</span>])</span><br><span class="line">    intersection_y2 = <span class="built_in">min</span>(cell[<span class="number">3</span>], text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> intersection_x1 &gt;= intersection_x2 <span class="keyword">or</span> intersection_y1 &gt;= intersection_y2:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    intersection_area = (intersection_x2 - intersection_x1) * (intersection_y2 - intersection_y1)</span><br><span class="line">    text_area = (text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">2</span>] - text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">0</span>]) * (text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">3</span>] - text[<span class="string">&#x27;coords&#x27;</span>][<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> intersection_area / text_area</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-函数-merge-text-into-cells-cell-coords-ocr-results"><a href="#2-函数-merge-text-into-cells-cell-coords-ocr-results" class="headerlink" title="2. 函数 merge_text_into_cells(cell_coords, ocr_results)"></a><strong>2. 函数 <code>merge_text_into_cells(cell_coords, ocr_results)</code></strong></h3><p><strong>功能</strong>：将 OCR 识别到的文字分配到表格对应单元格中。</p>
<p><strong>原理说明</strong>：</p>
<ul>
<li>对每个单元格遍历所有 OCR 文本框，计算 IoT。</li>
<li>若 IoT &gt; 0.5，则认为该文字属于该单元格。</li>
<li>同时记录那些与所有单元格 IoT &lt; 0.1 的文字（非表格内容）。</li>
<li>将属于单元格的文字合并为一个字符串。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_text_into_cells</span>(<span class="params">cell_coords, ocr_results</span>):</span><br><span class="line">    cell_text_dict = &#123;cell: [] <span class="keyword">for</span> cell <span class="keyword">in</span> cell_coords&#125;</span><br><span class="line">    noncell_text_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> cell_coords:</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> ocr_results:</span><br><span class="line">            <span class="keyword">if</span> calculate_iot(cell, result) &gt; <span class="number">0.5</span>:</span><br><span class="line">                cell_text_dict[cell].append(result[<span class="string">&#x27;text&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> ocr_results:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(calculate_iot(cell, result) &lt; <span class="number">0.1</span> <span class="keyword">for</span> cell <span class="keyword">in</span> cell_coords):</span><br><span class="line">            noncell_text_dict[result[<span class="string">&#x27;coords&#x27;</span>]] = result[<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    merged_text = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> cell, texts <span class="keyword">in</span> cell_text_dict.items():</span><br><span class="line">        merged_text[cell] = <span class="string">&#x27;&#x27;</span>.join(texts).strip()</span><br><span class="line">    <span class="keyword">for</span> coords, text <span class="keyword">in</span> noncell_text_dict.items():</span><br><span class="line">        merged_text[coords] = <span class="string">&#x27;&#x27;</span>.join(text).strip()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merged_text</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-函数-adjust-coordinates-merged-text-image-path"><a href="#3-函数-adjust-coordinates-merged-text-image-path" class="headerlink" title="3. 函数 adjust_coordinates(merged_text, image_path)"></a><strong>3. 函数 <code>adjust_coordinates(merged_text, image_path)</code></strong></h3><p><strong>功能</strong>：将 y 坐标相近的单元格进行聚类并统一化，方便后续行级别排序。</p>
<p><strong>原理说明</strong>：</p>
<ul>
<li>图像越高，容许的 y 偏差越大，使用 height &#x2F; 100 作为容差。</li>
<li>将 y 值差距小于阈值的单元格归为一组。</li>
<li>每组内统一 y 值为该组的平均 y 值，确保在同一“水平行”内。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">adjust_coordinates</span>(<span class="params">merged_text, image_path</span>):</span><br><span class="line">    image = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">    width, height = image.size</span><br><span class="line">    threshold = height / <span class="number">100</span></span><br><span class="line">    groups = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> coordinates, text <span class="keyword">in</span> merged_text.items():</span><br><span class="line">        found_group = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> group_y <span class="keyword">in</span> groups.keys():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(coordinates[<span class="number">1</span>] - group_y) &lt;= threshold:</span><br><span class="line">                groups[group_y].append((coordinates, text))</span><br><span class="line">                found_group = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> found_group:</span><br><span class="line">            groups[coordinates[<span class="number">1</span>]] = [(coordinates, text)]</span><br><span class="line"></span><br><span class="line">    adjusted_coordinates = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> group_y, group_coords <span class="keyword">in</span> groups.items():</span><br><span class="line">        avg_y = <span class="built_in">sum</span>(coord[<span class="number">0</span>][<span class="number">1</span>] <span class="keyword">for</span> coord <span class="keyword">in</span> group_coords) / <span class="built_in">len</span>(group_coords)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> group_coords:</span><br><span class="line">            adjusted_coordinates[(i[<span class="number">0</span>][<span class="number">0</span>], avg_y, i[<span class="number">0</span>][<span class="number">2</span>], i[<span class="number">0</span>][<span class="number">3</span>])] = i[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adjusted_coordinates</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-函数-draw-text-boxes-image-path-boxes-texts"><a href="#4-函数-draw-text-boxes-image-path-boxes-texts" class="headerlink" title="4.函数 draw_text_boxes(image_path, boxes, texts)"></a><strong>4.函数 <code>draw_text_boxes(image_path, boxes, texts)</code></strong></h3><p><strong>功能</strong>：在图像上绘制表格框与文字内容，进行可视化标注。</p>
<p><strong>原理说明</strong>：</p>
<ul>
<li>利用 PIL 创建空白图层，绘制框线与文字。</li>
<li>若文字宽度超出单元格宽度，则使用 textwrap 进行自动换行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">draw_text_boxes</span>(<span class="params">image_path, boxes, texts</span>):</span><br><span class="line">    img = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line">    img = Image.new(<span class="string">&#x27;RGB&#x27;</span>, img.size, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    font = ImageFont.truetype(<span class="string">&quot;./chinese_cht.ttf&quot;</span>, size=<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> box, text <span class="keyword">in</span> <span class="built_in">zip</span>(boxes, texts):</span><br><span class="line">        x0, y0, x1, y1 = box</span><br><span class="line">        x0, x1 = <span class="built_in">sorted</span>([x0, x1])</span><br><span class="line">        y0, y1 = <span class="built_in">sorted</span>([y0, y1])</span><br><span class="line">        normalized_box = (x0, y0, x1, y1)</span><br><span class="line">        draw.rectangle(normalized_box, outline=<span class="string">&#x27;red&#x27;</span>, width=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        text_len = draw.textbbox((x0, y0), text, font=font)</span><br><span class="line">        <span class="keyword">if</span> (text_len[<span class="number">2</span>] - text_len[<span class="number">0</span>]) &gt; (x1 - x0):</span><br><span class="line">            text = <span class="string">&#x27;\n&#x27;</span>.join(textwrap.wrap(text, width=<span class="built_in">int</span>(</span><br><span class="line">                np.ceil(<span class="built_in">len</span>(text) / np.ceil((text_len[<span class="number">2</span>] - text_len[<span class="number">0</span>]) / (x1 - x0))))))</span><br><span class="line"></span><br><span class="line">        draw.text((x0, y0), text, font=font, fill=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    img.save(<span class="string">&#x27;your_image_storage_path/output.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-最终文本输出（结构化行）"><a href="#5-最终文本输出（结构化行）" class="headerlink" title="5. 最终文本输出（结构化行）"></a><strong>5. 最终文本输出（结构化行）</strong></h2><p><strong>功能</strong>：将所有坐标按 y → x 排序，按行归组输出结构化文本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adjusted_merged_text_sorted = <span class="built_in">sorted</span>(adjusted_merged_text.items(), key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>][<span class="number">1</span>], x[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">adjusted_merged_text_sorted_group = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> coordinates, text <span class="keyword">in</span> adjusted_merged_text_sorted:</span><br><span class="line">    <span class="keyword">if</span> coordinates[<span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> adjusted_merged_text_sorted_group:</span><br><span class="line">        adjusted_merged_text_sorted_group[coordinates[<span class="number">1</span>]] = [text]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        adjusted_merged_text_sorted_group[coordinates[<span class="number">1</span>]].append(text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> text_list <span class="keyword">in</span> adjusted_merged_text_sorted_group.values():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27; | &#x27;</span>.join(text_list))</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><ol>
<li>运行脚本选择表格图片：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python Table_Extraction.py</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure>

<p>在项目目录会输出效果图片，终端会输出文本结果</p>
<ol start="2">
<li>效果展示<br><img src="https://github.com/user-attachments/assets/8e0f21d8-af6c-4da2-beb7-dcc7f5f73115" alt="image"><br><img src="https://github.com/user-attachments/assets/45ad3906-09df-431e-a4ec-4f0779137195" alt="image"><br>输出结果如下，你可以用这组结果测试大模型是否能读懂这组表格： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PartNumber | TotalCapacitance(Ct) @ 50 V,(pF) | TotalCapacitance(Ct) @ 0 V,(pF) | SeriesResistance (Rs),@10 mA,(②) | MinorityCarrierLifetime (TL)@ 10 mA(ns) | VoltageRating2(M) | I-RegionThickness(μm) | ThermalResistance(0JC)(°C/W)</span><br><span class="line">Maximum | Typical | Maximum | Typical | Minimum | Nominal | Maximum</span><br><span class="line"></span><br><span class="line">Switching Applications(continued)</span><br><span class="line">| APD0810-203 | 0.35 | 0.40 | 1.5 | 160 | 100 | 8 | 174</span><br><span class="line">| APD0810-210 | 0.40 | 0.45 | 1.5 | 160 | 100 | 8 | 75</span><br><span class="line">| APD0810-219 | 0.35 | 0.40 | 1.5 | 160 | 100 | 8 | 143</span><br><span class="line">| APD0810-240 | 0.35 | 0.40 | 1.5 | 160 | 100 | 8 | 155</span><br><span class="line">| APD1505-203 | 0.40 | 0.45@10V | 2.5 | 350 | 200 | 15 | 172</span><br><span class="line">| APD1505-210 | 0.40 | 0.45@10 V | 2.5 | 350 | 200 | 15 | 74</span><br><span class="line">| APD1505-219 | 0.40 | 0.45@10V | 2.5 | 350 | 200 | 15 | 142</span><br><span class="line">| APD1505-240 | 0.40 | 0.45 @ 10 V | 2.5 | 350 | 200 | 15 | 150</span><br><span class="line">| APD1510-203 | 0.35 | 0.40 | 2.0 | 300 | 200 | 15 | 168</span><br><span class="line">| APD1510-210 | 0.35 | 0.40 | 2.0 | 300 | 200 | 15 | 70</span><br><span class="line">| APD1510-219 | 0.35 | 0.40 | 2.0 | 300 | 200 | 15 | 137</span><br><span class="line">| APD1510-240 | 0.35 | 0.40 | 2.0 | 300 | 200 | 15 | 149</span><br><span class="line">| APD1520-203 | 0.40 | 0.45 | 1.2 | 900 | 200 | 15 | 155</span><br><span class="line">| APD1520-210 | 0.40 | 0.45 | 1.2 | 900 | 200 | 15 | 57</span><br><span class="line">| APD1520-219 | 0.45 | 0.50 | 1.2 | 900 | 200 | 15 | 124</span><br><span class="line">| APD1520-240 | 0.40 | 0.45 | 1.2 | 900 | 200 | 15 | 136</span><br><span class="line"></span><br><span class="line">AttenuatorApplications</span><br><span class="line">| APD2220-203 | 0.45 | 0.50 | 4.0 | 100 | 100 | 50 | 132</span><br><span class="line">| APD2220-210 | 0.45 | 0.50 | 4.0 | 100 | 100 | 50 | 32</span><br><span class="line">| APD2220-219 | 0.40 | 0.45 | 4.0 | 100 | 100 | 50 | 104</span><br><span class="line">| APD2220-240 | 0.40 | 0.45 | 4.0 | 100 | 100 | 50 | 115</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a><strong>补充说明</strong></h2><ul>
<li>字体文件 <code>chinese_cht.ttf</code> 必须存在，或替换为系统可识别的中文字体。</li>
<li>对于复杂结构表格，当前模型仍然无法很好的处理。</li>
</ul>
<hr>
<p>该项目代码基于 <a href="https://github.com/wyf3/llm_related/tree/main">wyf3</a> 和 <a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a></p>
]]></content>
      <categories>
        <category>OCR</category>
      </categories>
      <tags>
        <tag>OCR</tag>
        <tag>PaddleOCR</tag>
        <tag>PDF</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Custom Search Integration for Hexo Chic</title>
    <url>/2025/03/27/Custom-Search-Integration-for-Hexo-Chic/</url>
    <content><![CDATA[<h1 id="Hexo-Chic-主题实现搜索功能"><a href="#Hexo-Chic-主题实现搜索功能" class="headerlink" title="Hexo + Chic 主题实现搜索功能"></a>Hexo + Chic 主题实现搜索功能</h1><p>本文详细记录如何在 Hexo 中使用插件 <code>hexo-generator-searchdb</code> 实现基于 Chic 主题的实时搜索功能，包括搜索回复框、搜索结果卡、暗黑模式适配等细节。</p>
<hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Blog-Learning.git">https://github.com/EvannZhongg/Blog-Learning.git</a></p>
<hr>
<h2 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="1. 安装插件"></a><strong>1. 安装插件</strong></h2><p>在 <code>Hexo</code> 根目录下打开终端，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-打开根目录的-config-yml-文件，添加（或修改）如下配置："><a href="#2-打开根目录的-config-yml-文件，添加（或修改）如下配置：" class="headerlink" title="2. 打开根目录的 _config.yml 文件，添加（或修改）如下配置："></a><strong>2. 打开根目录的 <code>_config.yml</code> 文件，添加（或修改）如下配置：</strong></h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-新建-search-css"><a href="#3-新建-search-css" class="headerlink" title="3. 新建 search.css"></a><strong>3. 新建 search.css</strong></h2><p><strong>建议路径</strong>: <code>themes/hexo-theme-Chic/source/css/search.css</code></p>
<p>包含搜索框&#x2F;结果卡&#x2F;暗黑模式样式，具体代码可带文章开头项目地址中获取：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.search-container</span> &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.nav-search-input</span> &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.nav-search-result</span> &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.search-card</span> &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.dark-theme</span> <span class="selector-class">.nav-search-input</span> &#123; ... &#125;</span><br><span class="line"><span class="selector-class">.dark-theme</span> <span class="selector-class">.search-card-snippet</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-修改主题配置"><a href="#4-修改主题配置" class="headerlink" title="4. 修改主题配置"></a><strong>4. 修改主题配置</strong></h2><p>打开<code>theme/hexo-theme-Chic/_config.yml</code> ，在 <code>stylesheets </code>下增加一行 <code>search.css</code> 确保加载样式文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stylesheets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/css/style.css</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/css/search.css</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-修改-header-ejs"><a href="#5-修改-header-ejs" class="headerlink" title="5. 修改 header.ejs"></a><strong>5. 修改 <code>header.ejs</code></strong></h2><p>对 <code>theme/hexo-theme-Chic/layout/_partial/header.ejs</code> 做了如下关键修改，具体代码可带文章开头项目地址中获取：</p>
<h3 id="HTML-结构改动"><a href="#HTML-结构改动" class="headerlink" title="HTML 结构改动"></a>HTML 结构改动</h3><ol>
<li>在 <code>&lt;div class=&quot;menu navbar-right&quot;&gt;</code> 中插入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;search-container&quot;&gt;</span><br><span class="line">  &lt;a href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;&gt;🔍&lt;/a&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;nav-search-input&quot; class=&quot;nav-search-input&quot; placeholder=&quot;Search...&quot; oninput=&quot;navSearch(this)&quot;&gt;</span><br><span class="line">  &lt;div id=&quot;nav-search-result&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在移动端导航 <code>&lt;div id=&quot;mobile-menu&quot;&gt;</code> 中插入：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a class=&quot;menu-item&quot; href=&quot;javascript:;&quot; onclick=&quot;toggleSearchInput()&quot;&gt;🔍 Search&lt;/a&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;nav-search-input-mobile&quot; class=&quot;nav-search-input&quot; placeholder=&quot;Search...&quot; oninput=&quot;navSearch(this)&quot;&gt;</span><br><span class="line">&lt;div id=&quot;nav-search-result&quot; class=&quot;nav-search-result&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>保留并未更动主题切换按钮：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input id=&quot;switch_default&quot; type=&quot;checkbox&quot; class=&quot;switch_default&quot;&gt;</span><br><span class="line">&lt;label for=&quot;switch_default&quot; class=&quot;toggleBtn&quot;&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JS-功能改动"><a href="#JS-功能改动" class="headerlink" title="JS 功能改动"></a>JS 功能改动</h3><ol>
<li>新增 <code>toggleSearchInput()</code> 方法，实现点击图标展开或隐藏搜索框。</li>
<li></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toggleSearchInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.nav-search-input&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> results = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.nav-search-result&#x27;</span>);</span><br><span class="line">  inputs.<span class="title function_">forEach</span>(<span class="function"><span class="params">input</span> =&gt;</span> &#123;</span><br><span class="line">    input.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;active&#x27;</span>)) input.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">  results.<span class="title function_">forEach</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新增 <code>navSearch()</code> 方法，实现从 <code>search.xml</code> 加载数据并匹配关键词。</li>
<li>新增空白点击关闭逻辑：点击 <code>.search-container</code> 外部区域后自动隐藏搜索框并清空内容。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (searchData.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;&lt;%- config.root %&gt;search.xml&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">text</span>())</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">xmlText</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> parser = <span class="keyword">new</span> <span class="title class_">DOMParser</span>();</span><br><span class="line">        <span class="keyword">const</span> xml = parser.<span class="title function_">parseFromString</span>(xmlText, <span class="string">&#x27;text/xml&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> entries = xml.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;entry&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> entries) &#123;</span><br><span class="line">          searchData.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">title</span>: entry.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;title&#x27;</span>)[<span class="number">0</span>]?.<span class="property">textContent</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">content</span>: entry.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;content&#x27;</span>)[<span class="number">0</span>]?.<span class="property">textContent</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            <span class="attr">url</span>: entry.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;url&#x27;</span>)[<span class="number">0</span>]?.<span class="property">textContent</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-实现效果"><a href="#6-实现效果" class="headerlink" title="6. 实现效果"></a><strong>6. 实现效果</strong></h2><ul>
<li>点击图标展示搜索框</li>
<li>实时匹配文章标题&#x2F;内容</li>
<li>结果以卡片形式展示</li>
<li>黑色模式样式自动选择</li>
<li>点击空白地方隐藏结果 + 清空文本</li>
<li>移动端页面适配<br><img src="https://github.com/user-attachments/assets/430d306f-1836-4ca7-b1c6-c249835622bd" alt="image"></li>
</ul>
<hr>
<h2 id="7-新生成并运行-Hexo"><a href="#7-新生成并运行-Hexo" class="headerlink" title="7. 新生成并运行 Hexo"></a><strong>7. 新生成并运行 Hexo</strong></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后访问 <code>http://localhost:4000</code>，查看任意一段代码块，右上角应出现复制图标按钮。</p>
<hr>
<p>修改后的相关完整代码可以在文章开头的项目地址中获取</p>
<hr>
<p>该项目代码基于 <a href="https://github.com/hexojs/hexo.git">Hexo</a> , <a href="https://github.com/Siricee/hexo-theme-Chic.git">hexo-theme-Chic</a> 和 <a href="https://github.com/next-theme/hexo-generator-searchdb.git">hexo-generator-searchdb</a>。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Docling2md</title>
    <url>/2025/05/01/Docling2md/</url>
    <content><![CDATA[<h1 id="基于Docling结合多模态大模型的的PDF转Markdown"><a href="#基于Docling结合多模态大模型的的PDF转Markdown" class="headerlink" title="基于Docling结合多模态大模型的的PDF转Markdown"></a>基于Docling结合多模态大模型的的PDF转Markdown</h1><hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Docling2md.git">https://github.com/EvannZhongg/Docling2md.git</a></p>
<hr>
<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>基于我当前使用 LLM 构建<strong>知识图谱</strong>的处理的是一系列复杂的PDF文档，这些PDF包含图像、表格、文本等混合信息，结构复杂、不规则，无法直接使用。因此，需要一个高效、可扩展的结构化预处理流程来为后续实体提取、图谱生成等任务提供清洗后的输入，同时流程需要兼具准确和部署的方便。</p>
<p>例如 <code>MinerU</code> 和 <code>Textin</code> ，它们转换的效果都非常好；但 <code>MinerU</code> 部署不太方便集成到项目中显得笨重， <code>Textin</code> 是商用软件价格不美丽；于是近期发现了 <code>Docling</code> 的开源模型，同时python中也可以直接安装 <code>Docling</code> 的依赖包避免下载模型，于是尝试了一下感觉效果还不错符合我的预期。</p>
<p>尤其是在对表格进行处理时，<code>Docling</code> 是将表格转化为管道表格结构，而 <code>MinerU</code> 和 <code>Textin</code> 都是将表格转换为 HTML 格式；相比 HTML 格式，管道表格在传递给大模型时能够节省更多的token，减轻了大模型的负担。</p>
<p>本项目基于 <code>Docling</code> 框架，对 PDF 文件进行结构解析，结合多种大模型能力，实现了文档的多模态理解与 Markdown &#x2F; JSON 格式结构化输出，为知识图谱构建奠定基础。</p>
<hr>
<h2 id="实现的思想与目标"><a href="#实现的思想与目标" class="headerlink" title="实现的思想与目标"></a>实现的思想与目标</h2><p>项目的核心目标是提高PDF中信息保留的完整程度方便后续将纯文本信息输入给大模型构建知识图谱，并解决以下几个关键问题：</p>
<ol>
<li><strong>PDF转Markdown</strong>：通过Docling将PDF内容转化为Markdown，尤其是提取表格和图片，并在Markdown中保持其结构。</li>
<li><strong>复杂表格图像的处理与修复</strong>：通过视觉大模型处理PDF中的表格图片，修复异常或模糊的表格结构。</li>
<li><strong>异常文本分词的修复</strong>：直接使用 <code>Docling</code> 的OCR有时会出现文本识别异常，对于长文本中的异常无空格情况，通过大模型进行自动分词修复，保证文本可读性。</li>
<li><strong>对图片的描述与理解</strong>: 对识别出的图像（非表格）调用视觉大模型进行内容描述，生成自然语言图像摘要，并写入 Markdown 与结构 JSON。</li>
</ol>
<p>流程示意：</p>
<pre class="mermaid">graph TD
    A[PDF Document] --> B[DocumentConverter]
    B --> C[Structured Document]
    C --> D[Element Iteration]

    D --> E[Text Processing]
    D --> F[Table Processing]
    D --> G[Image Processing]

    E --> H[LLM Classification]
    F --> I[Table Structure Analysis]
    G --> J[VLM Captioning]

    H --> K[Markdown Output]
    I --> K
    J --> K

    K --> L[Markdown File]
    K --> M[JSON Metadata]
    K --> N[Extracted Images]</pre>

<hr>
<h2 id="项目流程与技术细节"><a href="#项目流程与技术细节" class="headerlink" title="项目流程与技术细节"></a>项目流程与技术细节</h2><h3 id="1-表格结构识别与修复"><a href="#1-表格结构识别与修复" class="headerlink" title="1. 表格结构识别与修复"></a>1. 表格结构识别与修复</h3><ul>
<li>使用 Docling 自动检测表格区域，导出 <code>DataFrame</code>。</li>
<li>若存在列名重复或列数异常，启用视觉大模型模型对表格截图分块修复，生成标准 Markdown 管道表格（pipe table）。</li>
<li>分块方式：按行高切图，并拼接小块确保高度。</li>
<li>所有修复表格记录修复来源，存入 JSON 中以备审计与训练数据回溯。</li>
</ul>
<p>表格异常处理的流程结合了 <strong>按固定行高切块</strong> 和 <strong>基于最低高度与宽度的分块合并</strong> 两种方法。</p>
<hr>
<h4 id="按固定行高切块"><a href="#按固定行高切块" class="headerlink" title="按固定行高切块"></a>按固定行高切块</h4><p>在函数 <code>split_table_image_rows</code> 中，表格图像被按照固定的行高（默认为 400 像素）进行裁切。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def split_table_image_rows(pil_img: Image.Image, row_height: int = 400) -&gt; list:</span><br><span class="line">    width, height = pil_img.size</span><br><span class="line">    slices = []</span><br><span class="line">    for top in range(0, height, row_height):</span><br><span class="line">        bottom = min(top + row_height, height)</span><br><span class="line">        crop = pil_img.crop((0, top, width, bottom))</span><br><span class="line">        slices.append(crop)</span><br><span class="line">    return slices</span><br></pre></td></tr></table></figure>
<p>根据您上传的代码文件内容，表格异常处理的流程结合了<strong>按固定行高切块</strong>和<strong>基于最低高度与宽度的分块合并</strong>两种方法。以下是具体的实现细节和举例说明：</p>
<ul>
<li><strong>输入</strong>: 表格图像 <code>pil_img</code> 和一个可配置的 <code>row_height</code>（默认值为 400 像素）。</li>
<li><strong>逻辑</strong>: <ul>
<li>按照从上到下的顺序，每隔 <code>row_height</code> 像素裁切一次。</li>
<li>如果剩余的高度不足 <code>row_height</code>，则取到最后的边界。</li>
</ul>
</li>
<li><strong>输出</strong>: 返回一个包含多个裁切后图像片段的列表。</li>
</ul>
<p>这种方式确保了表格图像能够被分割成多个子图像，每个子图像的高度不超过 <code>row_height</code>。</p>
<hr>
<h4 id="基于最低高度与宽度的分块合并"><a href="#基于最低高度与宽度的分块合并" class="headerlink" title="基于最低高度与宽度的分块合并"></a>基于最低高度与宽度的分块合并</h4><p>在函数 <code>merge_small_chunks</code> 中，对裁切后的图像片段进一步处理，确保每个片段的高度和宽度满足最低要求（因为视觉大模型在上传图片时有最小像素要求，需要长宽大于 10 像素，为避免切块过小，这里默认高度为 300 像素，宽度为 20 像素）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def merge_small_chunks(chunks: list, min_height: int = 300, min_width: int = 20) -&gt; list:</span><br><span class="line">    merged_chunks = []</span><br><span class="line">    temp_chunk = None</span><br><span class="line">    for chunk in chunks:</span><br><span class="line">        width, height = chunk.size</span><br><span class="line">        # 如果当前块尺寸不足，则尝试拼接上下块</span><br><span class="line">        if height &lt; min_height or width &lt; min_width:</span><br><span class="line">            if temp_chunk is None:</span><br><span class="line">                temp_chunk = chunk</span><br><span class="line">            else:</span><br><span class="line">                # 拼接上下块</span><br><span class="line">                new_chunk = Image.new(&quot;RGB&quot;, (max(temp_chunk.width, chunk.width), temp_chunk.height + chunk.height))</span><br><span class="line">                new_chunk.paste(temp_chunk, (0, 0))</span><br><span class="line">                new_chunk.paste(chunk, (0, temp_chunk.height))</span><br><span class="line">                temp_chunk = new_chunk</span><br><span class="line">        else:</span><br><span class="line">            # 如果有未处理的临时块，先保存</span><br><span class="line">            if temp_chunk is not None:</span><br><span class="line">                merged_chunks.append(temp_chunk)</span><br><span class="line">                temp_chunk = None</span><br><span class="line">            merged_chunks.append(chunk)</span><br><span class="line">    # 添加最后一个临时块（如果有）</span><br><span class="line">    if temp_chunk is not None:</span><br><span class="line">        # 如果整个表格图片的高度低于最小高度，则按最低高度计算</span><br><span class="line">        if temp_chunk.height &lt; min_height:</span><br><span class="line">            new_chunk = Image.new(&quot;RGB&quot;, (temp_chunk.width, max(temp_chunk.height, 20)))</span><br><span class="line">            new_chunk.paste(temp_chunk, (0, 0))</span><br><span class="line">            merged_chunks.append(new_chunk)</span><br><span class="line">        else:</span><br><span class="line">            merged_chunks.append(temp_chunk)</span><br><span class="line">    return merged_chunks</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>输入</strong>: 裁切后的图像片段列表 <code>chunks</code>，以及最低高度 <code>min_height</code>（默认 300 像素）和最低宽度 <code>min_width</code>（默认 20 像素）。</li>
<li><strong>逻辑</strong>:<ul>
<li>遍历所有片段：<ul>
<li>如果某个片段的高度或宽度小于最低要求，则将其与下一个片段拼接，直到满足最低尺寸要求。</li>
<li>如果某个片段已经满足最低要求，则直接加入结果列表。</li>
</ul>
</li>
<li>对于最后一个临时块，如果其高度仍低于最低要求，则创建一个新的图像块，填充到最低高度。</li>
</ul>
</li>
<li><strong>输出</strong>: 返回一个经过合并后的图像片段列表。</li>
</ul>
<hr>
<h4 id="3-综合处理流程"><a href="#3-综合处理流程" class="headerlink" title="3. 综合处理流程"></a>3. <strong>综合处理流程</strong></h4><p>在主流程中，表格异常的处理逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if not table_df.columns.is_unique or table_df.shape[1] &lt; 2:</span><br><span class="line">    log.warning(f&quot;表格 &#123;table_counter&#125; 结构异常，使用多轮图像推理修复&quot;)</span><br><span class="line">    # 自动图像切块</span><br><span class="line">    sub_images = split_table_image_rows(pil_img)</span><br><span class="line">    # 拼接不符合尺寸限制的切块</span><br><span class="line">    sub_images = merge_small_chunks(sub_images)</span><br><span class="line"></span><br><span class="line">    # 使用局部变量管理该表格的修复任务</span><br><span class="line">    chunk_futures = []</span><br><span class="line">    for idx, chunk_img in enumerate(sub_images):</span><br><span class="line">        future = vlm_executor.submit(ask_table_from_image, chunk_img)</span><br><span class="line">        chunk_futures.append((future, idx, chunk_img))</span><br><span class="line"></span><br><span class="line">    # 收集结果</span><br><span class="line">    full_md_lines = []</span><br><span class="line">    for future, idx, chunk_img in chunk_futures:</span><br><span class="line">        try:</span><br><span class="line">            chunk_md = future.result()</span><br><span class="line">            lines = chunk_md.splitlines()</span><br><span class="line">            if idx == 0:</span><br><span class="line">                full_md_lines.extend(lines)  # 表头 + 分隔线</span><br><span class="line">            else:</span><br><span class="line">                full_md_lines.extend(lines[2:])  # 仅数据行</span><br><span class="line">        except Exception as e:</span><br><span class="line">            log.warning(f&quot;表格分块处理失败: &#123;e&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    markdown_lines.append(f&quot;&lt;!-- 表格 &#123;table_counter&#125; 使用 Qwen 修复，已分块拼接 --&gt;&quot;)</span><br><span class="line">    markdown_lines.append(&quot;\n&quot;.join(full_md_lines))</span><br><span class="line">    markdown_lines.append(&quot;&quot;)</span><br><span class="line">    json_data.append(&#123;</span><br><span class="line">        &quot;type&quot;: &quot;table&quot;,</span><br><span class="line">        &quot;level&quot;: level,</span><br><span class="line">        &quot;image&quot;: table_image_filename.name,</span><br><span class="line">        &quot;source&quot;: &quot;reconstructed_by_qwen_chunked&quot;,</span><br><span class="line">        &quot;markdown&quot;: &quot;\n&quot;.join(full_md_lines),</span><br><span class="line">        &quot;page_number&quot;: element.prov[0].page_no,</span><br><span class="line">        &quot;bbox&quot;: bbox</span><br><span class="line">    &#125;)</span><br><span class="line">    continue </span><br></pre></td></tr></table></figure>

<h4 id="流程说明："><a href="#流程说明：" class="headerlink" title="流程说明："></a>流程说明：</h4><ol>
<li><strong>检测表格异常</strong>:<ul>
<li>如果表格的列名不唯一 (<code>table_df.columns.is_unique</code>) 或者列数少于 2 (<code>table_df.shape[1] &lt; 2</code>)，认为表格结构异常，这些异常通常是 OCR 模型本身的不足导致的表格生成失败。</li>
</ul>
</li>
<li><strong>按固定行高切块</strong>:<ul>
<li>使用 <code>split_table_image_rows</code> 将表格图像按固定行高（默认 400 像素）切分为多个片段。</li>
</ul>
</li>
<li><strong>合并小块</strong>:<ul>
<li>使用 <code>merge_small_chunks</code> 合并高度或宽度不足的片段，确保每个片段的高度至少为 300 像素，宽度至少为 20 像素。</li>
</ul>
</li>
<li><strong>并发调用大模型</strong>:<ul>
<li>对每个合并后的片段并发调用 <code>ask_table_from_image</code> 函数，将图像转换为 Markdown 表格。</li>
</ul>
</li>
<li><strong>拼接结果</strong>:<ul>
<li>将所有片段的 Markdown 表格拼接起来：<ul>
<li>第一个片段保留表头和分割线。</li>
<li>其余片段仅保留数据行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>保存结果</strong>:<ul>
<li>将修复后的表格以 Markdown 格式保存，并记录相关信息到 JSON 文件中。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4><p>假设我们有一个PDF文件，其中包含一个异常的表格图像。该表格的高度为 <strong>1208 像素</strong>，宽度为 <strong>900 像素</strong>，代码会按照以下步骤处理该表格图像：</p>
<p>在函数 <code>split_table_image_rows</code> 中，表格图像会被按固定行高（默认为 400 像素）进行裁切。</p>
<ul>
<li>表格高度为 <strong>1208 像素</strong>，固定行高为 <strong>400 像素</strong>。</li>
<li>裁切的片段范围如下：<ul>
<li>第一块：<code>top=0</code>, <code>bottom=400</code> → 高度为 400 像素。</li>
<li>第二块：<code>top=400</code>, <code>bottom=800</code> → 高度为 400 像素。</li>
<li>第三块：<code>top=800</code>, <code>bottom=1200</code> → 高度为 400 像素。</li>
<li>第四块：<code>top=1200</code>, <code>bottom=1208</code> → 高度为 8 像素。</li>
</ul>
</li>
</ul>
<p>最终会生成 <strong>4 个片段</strong>，其中前 3 个片段的高度为 400 像素，最后一个片段的高度为 8 像素。</p>
<p>在函数 <code>merge_small_chunks</code> 中，会对裁切后的片段进行检查，确保每个片段的高度和宽度满足最低要求（默认高度为 300 像素，宽度为 20 像素）。</p>
<ul>
<li><strong>第一块</strong>：高度为 400 像素，宽度为 900 像素 → 符合最低要求，直接保留。</li>
<li><strong>第二块</strong>：高度为 400 像素，宽度为 900 像素 → 符合最低要求，直接保留。</li>
<li><strong>第三块</strong>：高度为 400 像素，宽度为 900 像素 → 符合最低要求，直接保留。</li>
<li><strong>第四块</strong>：高度为 8 像素，宽度为 900 像素 → 不符合最低高度要求（300 像素），需要与前面的块合并。</li>
</ul>
<p>最终结果：</p>
<ul>
<li><strong>第四块（8 像素）</strong> 会与 <strong>第三块（400 像素）</strong> 合并，生成一个新的片段，高度为 <strong>408 像素</strong>，宽度为 <strong>900 像素</strong>。</li>
</ul>
<p>因此，经过合并后，最终会有 <strong>3 个片段</strong>：</p>
<ol>
<li>第一块：高度为 400 像素，宽度为 900 像素。</li>
<li>第二块：高度为 400 像素，宽度为 900 像素。</li>
<li>第三块：高度为 408 像素，宽度为 900 像素。</li>
</ol>
<p>在主流程中，合并后的片段会并发调用视觉模型（<code>ask_table_from_image</code>）进行修复，在收集所有片段的修复结果后，代码会将这些片段拼接成完整的 Markdown 表格。</p>
<ul>
<li><strong>第一块</strong> 的修复结果会保留表头和分割线。</li>
<li><strong>第二块</strong> 和 <strong>第三块</strong> 的修复结果只会保留数据行。</li>
<li>最终将所有片段的结果拼接成一个完整的 Markdown 表格。</li>
</ul>
<h4 id="使用视觉模型修复表格示例效果展示"><a href="#使用视觉模型修复表格示例效果展示" class="headerlink" title="使用视觉模型修复表格示例效果展示"></a>使用视觉模型修复表格示例效果展示</h4><p><img src="https://github.com/user-attachments/assets/ab583ea5-b8b2-4466-a6ed-ea8b43f21bd9" alt="709f27681f3bf94551b729283c54046a-table-17"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| tD(on)  | - | 20 | - | ns | V_DS=400V, V_GS=0 - 12V, I_D=3A, R_G=30Ω |</span><br><span class="line">| ------- | - | -- | - | -- | ---------------------------------------- |</span><br><span class="line">| tR      | - | 7  | - | ns | V_DS=400V, V_GS=0 - 12V, I_D=3A, R_G=30Ω |</span><br><span class="line">| tD(off) | - | 80 | - | ns | V_DS=400V, V_GS=0 - 12V, I_D=3A, R_G=30Ω |</span><br><span class="line">| tF      | - | 6  | - | ns | V_DS=400V, V_GS=0 - 12V, I_D=3A, R_G=30Ω |</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-文本内容处理"><a href="#2-文本内容处理" class="headerlink" title="2. 文本内容处理"></a>2. 文本内容处理</h3><ul>
<li>使用 OCR 与 Docling 检测文本段落。</li>
<li>文本类型判断：使用 OpenAI 文本模型判断是“标题”还是“正文”。</li>
<li>英文分词修复机制：检测长串无空格文本，调用大模型进行英文分词恢复，提高可读性与准确性。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例输入：</span><br><span class="line">THISISATESTSTRING</span><br><span class="line"></span><br><span class="line">示例输出：</span><br><span class="line">THIS IS A TEST STRING</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-图片内容理解"><a href="#3-图片内容理解" class="headerlink" title="3. 图片内容理解"></a>3. 图片内容理解</h3><ul>
<li>对识别出的图像（非表格）调用视觉大模型进行内容描述，生成自然语言图像摘要，并写入 Markdown 与结构 JSON。</li>
<li>摘要会插入在图片 <code>alt text</code> 中，例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![这是一个苹果](./1ca13ed90bf22bae348f93027fb876d5-picture-2.png)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-生成Markdown文档"><a href="#4-生成Markdown文档" class="headerlink" title="4. 生成Markdown文档"></a>4. <strong>生成Markdown文档</strong></h3><p>在完成表格和图片的提取、文本处理之后，最终将所有提取的信息转换为Markdown文档，并保存到本地。每个表格、图像、文本都会被格式化成相应的Markdown格式，并以图像和表格形式嵌入。</p>
<ul>
<li>Markdown 文档（结构化展示图像、表格、文本，便于人工核查与发布）</li>
<li>JSON 文档（结构化、含坐标 bbox、页码、分块来源，适合下游知识图谱任务进行锚点的标记）</li>
</ul>
<hr>
<p>该项目代码参考 <a href="https://github.com/openfe-docling/docling">Docling</a> 框架，对 PDF 文件进行结构解析，结合多种大模型能力（如 Qwen-VL、OpenAI 文本模型），实现了文档的多模态理解与 Markdown &#x2F; JSON 格式结构化输出，为知识图谱构建奠定基础。</p>
<p>但该项目在处理复杂表格时仍存在不足，例如表格中存在字符是横着摆放时，或者是存在图像嵌入在表格中，则无法保证原有的结构。</p>
<hr>
]]></content>
      <categories>
        <category>OCR</category>
      </categories>
      <tags>
        <tag>OCR</tag>
        <tag>PDF</tag>
        <tag>AI</tag>
        <tag>Markdown</tag>
        <tag>LLM</tag>
        <tag>大模型</tag>
        <tag>Qwen</tag>
        <tag>Docling</tag>
        <tag>Knowledge Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Function Calling</title>
    <url>/2025/03/21/Function-Calling/</url>
    <content><![CDATA[<h1 id="Qwen-Function-Calling-详细解析"><a href="#Qwen-Function-Calling-详细解析" class="headerlink" title="Qwen Function Calling 详细解析"></a>Qwen Function Calling 详细解析</h1><hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Blog-Learning.git">https://github.com/EvannZhongg/Blog-Learning.git</a></p>
<hr>
<h2 id="1-Function-Calling-简介"><a href="#1-Function-Calling-简介" class="headerlink" title="1. Function Calling 简介"></a><strong>1. Function Calling 简介</strong></h2><p>Function Calling 允许 LLM（大语言模型）在回答问题时调用外部工具，如 Python 函数、API 或数据库查询。</p>
<p><strong>核心流程：</strong></p>
<ol>
<li><strong>用户输入问题</strong></li>
<li><strong>AI 判断是否需要调用工具</strong></li>
<li><strong>如果需要，AI 返回 <code>tool_calls</code>，请求调用特定函数</strong></li>
<li><strong>开发者执行对应的 Python 函数，并返回执行结果</strong></li>
<li><strong>AI 读取工具返回值，继续推理并生成最终回答</strong></li>
</ol>
<h2 id="2-代码拆解：Function-Calling-功能实现"><a href="#2-代码拆解：Function-Calling-功能实现" class="headerlink" title="2. 代码拆解：Function Calling 功能实现"></a><strong>2. 代码拆解：Function Calling 功能实现</strong></h2><p>本文定义了一个read_markdown函数，用于通过提问让大模型自主调用函数阅读markdown文本内容，回答问题。</p>
<h3 id="（1）初始化-Qwen-客户端"><a href="#（1）初始化-Qwen-客户端" class="headerlink" title="（1）初始化 Qwen 客户端"></a><strong>（1）初始化 Qwen 客户端</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = OpenAI(</span><br><span class="line">    api_key=<span class="string">&quot;your_api_key&quot;</span>,</span><br><span class="line">    base_url=<span class="string">&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>连接 Qwen API 进行请求。</li>
<li><code>api_key</code> 必须正确，否则请求会失败。</li>
</ul>
<hr>
<h3 id="（2）定义工具（Function-Calling）"><a href="#（2）定义工具（Function-Calling）" class="headerlink" title="（2）定义工具（Function Calling）"></a><strong>（2）定义工具（Function Calling）</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tools = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;read_markdown&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;读取 &#x27;documents&#x27; 文件夹中的 Markdown 文档。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;&#125;,  <span class="comment"># 这个工具不需要参数</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>告诉 Qwen 可调用的工具。</li>
<li><code>name</code> 必须与 Python 函数名一致，否则无法正确调用。</li>
<li><code>description</code> 用于让 AI 知道工具的用途。</li>
<li>在 Qwen 的 Function Calling 中，工具的<code>parameters</code> 的 <code>type</code> 必须是 <code>object</code>。</li>
<li><code>parameters</code> 为空 <code>&#123;&#125;</code>，表示此工具不需要参数。</li>
<li><code>parameters</code> <strong>如果不为空</strong>，表示此工具需要<strong>传递参数</strong>。<ul>
<li><code>properties</code> 定义了每个参数的名称、类型和描述。</li>
<li><code>required</code> 指定了哪些参数是必填项。</li>
</ul>
</li>
</ul>
<p>如果代码中涉及到了多个工具的调用，可按照以下的格式进行多个工具的定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tools = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;read_markdown&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;读取 &#x27;documents&#x27; 文件夹中的 Markdown 文档。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;&#125;,  <span class="comment"># 这个工具不需要参数</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;function&quot;</span>,</span><br><span class="line">        <span class="string">&quot;function&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;fetch_weather&quot;</span>,</span><br><span class="line">            <span class="string">&quot;description&quot;</span>: <span class="string">&quot;获取指定城市的天气信息。&quot;</span>,</span><br><span class="line">            <span class="string">&quot;parameters&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">                <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;city&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;description&quot;</span>: <span class="string">&quot;要查询天气的城市名称&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">&quot;required&quot;</span>: [<span class="string">&quot;city&quot;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例解释：</strong></p>
<ul>
<li><code>read_markdown</code> <strong>不需要参数</strong>，所以 <code>properties</code> 为空。</li>
<li><code>fetch_weather</code> <strong>需要参数</strong>，它的 <code>parameters</code> 里包含 <code>city</code> 这个字符串参数。</li>
<li>AI 在调用 <code>fetch_weather</code> 时，会传递 JSON 结构的 <code>arguments</code>，如：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Shanghai&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="（3）读取-Markdown-文件"><a href="#（3）读取-Markdown-文件" class="headerlink" title="（3）读取 Markdown 文件"></a><strong>（3）读取 Markdown 文件</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_markdown</span>():</span><br><span class="line">    doc_path = <span class="string">&quot;documents&quot;</span></span><br><span class="line">    md_file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(doc_path):</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&quot;.md&quot;</span>):</span><br><span class="line">            md_file = os.path.join(doc_path, file)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> md_file:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No markdown file found in the &#x27;documents&#x27; folder.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(md_file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content[:<span class="number">5000</span>]</span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>读取 <code>documents/</code> 目录下后缀为 <code>.md</code> 文件。</li>
<li>限制 5000 字符，防止超出 Token 限制。</li>
<li>将<code>markdown</code>文本的前5000个字符传递给AI。</li>
</ul>
<hr>
<h3 id="（4）获取天气信息（示例工具）"><a href="#（4）获取天气信息（示例工具）" class="headerlink" title="（4）获取天气信息（示例工具）"></a><strong>（4）获取天气信息（示例工具）</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_weather</span>(<span class="params">city</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取指定城市的天气信息。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;当前 <span class="subst">&#123;city&#125;</span> 的天气：晴，25°C&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>模拟获取天气信息，<strong>参数 <code>city</code> 必须传递</strong>。</li>
<li>Qwen 在调用 <code>fetch_weather</code> 时，会自动提供 <code>city</code> 的值。</li>
</ul>
<h3 id="（5）主逻辑：工具调用的完整流程"><a href="#（5）主逻辑：工具调用的完整流程" class="headerlink" title="（5）主逻辑：工具调用的完整流程"></a><strong>（5）主逻辑：工具调用的完整流程</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    user_question = <span class="built_in">input</span>(<span class="string">&quot;请输入问题：&quot;</span>).strip()</span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: user_question&#125;]</span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>让用户输入问题，并存入 <code>messages</code> 作为对话历史。</li>
</ul>
<hr>
<h3 id="（6）第一次请求：看看-AI-是否调用工具"><a href="#（6）第一次请求：看看-AI-是否调用工具" class="headerlink" title="（6）第一次请求：看看 AI 是否调用工具"></a><strong>（6）第一次请求：看看 AI 是否调用工具</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">completion = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">&quot;qwen-plus&quot;</span>,</span><br><span class="line">    messages=messages,</span><br><span class="line">    tools=tools</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>调用 Qwen，让其决定是否需要调用工具。</li>
</ul>
<hr>
<h3 id="（7）检查-Qwen-是否调用了工具"><a href="#（7）检查-Qwen-是否调用了工具" class="headerlink" title="（7）检查 Qwen 是否调用了工具"></a><strong>（7）检查 Qwen 是否调用了工具</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> tool_calls:</span><br><span class="line">    tool_results = []</span><br><span class="line">    <span class="keyword">for</span> tool_call <span class="keyword">in</span> tool_calls:</span><br><span class="line">        tool_name = tool_call[<span class="string">&quot;function&quot;</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        tool_id = tool_call[<span class="string">&quot;id&quot;</span>]</span><br><span class="line">        tool_args = tool_call[<span class="string">&quot;function&quot;</span>][<span class="string">&quot;arguments&quot;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> tool_name == <span class="string">&quot;read_markdown&quot;</span>:</span><br><span class="line">            result_content = read_markdown()</span><br><span class="line">        <span class="keyword">elif</span> tool_name == <span class="string">&quot;fetch_weather&quot;</span>:</span><br><span class="line">            city = tool_args.get(<span class="string">&quot;city&quot;</span>, <span class="string">&quot;未知城市&quot;</span>)</span><br><span class="line">            result_content = fetch_weather(city)</span><br><span class="line">        </span><br><span class="line">        tool_results.append(&#123;</span><br><span class="line">            <span class="string">&quot;role&quot;</span>: <span class="string">&quot;tool&quot;</span>,</span><br><span class="line">            <span class="string">&quot;tool_call_id&quot;</span>: tool_id,</span><br><span class="line">            <span class="string">&quot;content&quot;</span>: result_content</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>解析 Qwen 返回的 <code>tool_calls</code>。</li>
<li><strong>调用不同的工具</strong>，如 <code>read_markdown()</code> 或 <code>fetch_weather(city)</code> ，并存入 <code>tool</code> 消息。</li>
<li><strong>如果工具需要参数</strong>，就从 <code>tool_args</code> 里提取。</li>
<li>若 <code>tool_calls</code> 为空，说明 AI <strong>不需要调用工具</strong>。</li>
</ul>
<hr>
<h3 id="（8）让-Qwen-继续推理"><a href="#（8）让-Qwen-继续推理" class="headerlink" title="（8）让 Qwen 继续推理"></a><strong>（8）让 Qwen 继续推理</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">messages.append(&#123;</span><br><span class="line">    <span class="string">&quot;role&quot;</span>: <span class="string">&quot;assistant&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tool_calls&quot;</span>: tool_calls</span><br><span class="line">&#125;)</span><br><span class="line">messages.extend(tool_results)</span><br><span class="line"></span><br><span class="line">completion2 = client.chat.completions.create(</span><br><span class="line">    model=<span class="string">&quot;qwen-plus&quot;</span>,</span><br><span class="line">    messages=messages,</span><br><span class="line">    tools=tools</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>作用：</strong></p>
<ul>
<li>让 Qwen <strong>读取工具返回值，并继续回答</strong>。</li>
</ul>
<hr>
<p>效果测试：</p>
<p align="center">
  <img width="1198" alt="function_calling" src="https://github.com/user-attachments/assets/6da63b40-55b2-4eb0-b13c-b5f30225ff33" />
</p>

<hr>
<h2 id="3-以下是我在测试的时候一些工具调用失败的原因"><a href="#3-以下是我在测试的时候一些工具调用失败的原因" class="headerlink" title="3. 以下是我在测试的时候一些工具调用失败的原因"></a><strong>3. 以下是我在测试的时候一些工具调用失败的原因</strong></h2><ol>
<li><code>name</code> 和 Python 函数不匹配，导致 AI 无法正确调用工具。</li>
<li><code>role=&quot;tool&quot;</code> 消息未紧跟 <code>assistant</code>，导致 AI 解析错误。</li>
</ol>
<ul>
<li>解决方法是在调用完工具之后，向 messages 中手动插入一条 role&#x3D;”assistant” 的空消息，附带 tool_calls 字段，然后紧接着添加 role&#x3D;”tool” 的返回结果，这样就保证了正确的调用链路。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">messages.append(&#123;</span><br><span class="line">    &quot;role&quot;: &quot;assistant&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;&quot;,  # 一定为空</span><br><span class="line">    &quot;tool_calls&quot;: tool_calls  # 将 AI 最初返回的 tool_calls 原样放回</span><br><span class="line">&#125;)</span><br><span class="line">messages.extend(tool_results)  # 马上接上 tool 返回值</span><br></pre></td></tr></table></figure></li>
<li>因为 Qwen 模型的调用链规则如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户消息（role=&quot;user&quot;）</span><br><span class="line">→ AI 返回 tool_calls（role=&quot;assistant&quot;，tool_calls）</span><br><span class="line">→ 工具执行，返回结果（role=&quot;tool&quot;，tool_call_id）</span><br><span class="line">→ AI 接收到结果，继续推理</span><br></pre></td></tr></table></figure></li>
<li>如果 role&#x3D;”tool” 的消息不紧跟在带有 tool_calls 的 assistant 消息后面，模型就无法对上“这个工具调用返回了这个值”，于是会报错或输出异常。</li>
</ul>
<ol start="3">
<li><code>parameters</code> 设置错误，导致 AI 传递了错误的参数。</li>
<li><code>messages</code> 结构错误，导致 AI 不能正确读取历史对话。</li>
</ol>
<hr>
<p>该项目代码参考 <a href="https://help.aliyun.com/zh/model-studio/user-guide/qwen-function-calling?spm=0.0.0.i4#8c41d25020ipz">Qwen官方Function Calling</a>。</p>
]]></content>
      <categories>
        <category>LLM学习之路</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大模型</tag>
        <tag>Qwen</tag>
        <tag>Function Calling</tag>
        <tag>Agent</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>GraphRag Visualization</title>
    <url>/2025/04/11/GraphRag-Visualization/</url>
    <content><![CDATA[<h1 id="GraphRag-图谱可视化"><a href="#GraphRag-图谱可视化" class="headerlink" title="GraphRag 图谱可视化"></a>GraphRag 图谱可视化</h1><p>本文将详细介绍如何将微软 GraphRAG 框架生成的 <code>entities.parquet</code> 与 <code>relationships.parquet</code> 文件转换为 GraphML 图结构在 Gephi 中实现可视化。我们将逐步解释数据格式、图构建逻辑及 Python 代码实现的每个模块功能。</p>
<hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Blog-Learning.git">https://github.com/EvannZhongg/Blog-Learning.git</a></p>
<hr>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="https://github.com/user-attachments/assets/df017c54-9d42-4708-bf90-7a6a7f25a632" alt="image"></p>
<hr>
<h2 id="1-GraphRAG-简介与数据说明"><a href="#1-GraphRAG-简介与数据说明" class="headerlink" title="1. GraphRAG 简介与数据说明"></a>1. GraphRAG 简介与数据说明</h2><p>Microsoft GraphRAG 是一种结合图结构与检索增强生成（<strong>Retrieval-Augmented Generation</strong>）的知识增强方案。它会自动从文本中提取实体及其关系，分别存储为 <code>entities.parquet</code> 和 <code>relationships.parquet</code> 文件。用户可基于此图谱进行可视化分析、结构化检索及上下文增强生成任务。</p>
<p>如果不知道怎么配置 GraphRag，可以参考<a href="https://microsoft.github.io/graphrag/get_started/">官方文档</a></p>
<p>GraphRAG 输出文件说明如下：</p>
<h3 id="1-entities-parquet"><a href="#1-entities-parquet" class="headerlink" title="1. entities.parquet"></a>1. <code>entities.parquet</code></h3><p>该文件用于存储图中的节点信息，每一行表示一个实体（节点）。字段如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>实体的唯一标识（主键）</td>
</tr>
<tr>
<td><code>human_readable_id</code></td>
<td>可读ID（序号或别名）</td>
</tr>
<tr>
<td><code>title</code></td>
<td>实体的标题或名称</td>
</tr>
<tr>
<td><code>type</code></td>
<td>实体类型（如概念&#x2F;术语）</td>
</tr>
<tr>
<td><code>description</code></td>
<td>实体的文本描述信息</td>
</tr>
<tr>
<td><code>text_unit_ids</code></td>
<td>所属文本单元ID集合</td>
</tr>
<tr>
<td><code>frequency</code></td>
<td>出现频率</td>
</tr>
<tr>
<td><code>degree</code></td>
<td>在图中的连接度（可选）</td>
</tr>
<tr>
<td><code>x</code>, <code>y</code></td>
<td>可视化坐标（可选）</td>
</tr>
</tbody></table>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id: 053f7bde-5adf-4185-9964-0d51ccc5c313</span><br><span class="line">title: Transformer Model</span><br><span class="line">type: Concept</span><br><span class="line">description: A deep learning model architecture...</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-relationships-parquet"><a href="#2-relationships-parquet" class="headerlink" title="2. relationships.parquet"></a>2. <code>relationships.parquet</code></h3><p>该文件表示图中的边（关系），每一行表示两个实体之间的连线及其属性。</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>关系的唯一ID</td>
</tr>
<tr>
<td><code>human_readable_id</code></td>
<td>可读ID</td>
</tr>
<tr>
<td><code>source</code></td>
<td>起点实体的ID（对应entities.id）</td>
</tr>
<tr>
<td><code>target</code></td>
<td>终点实体的ID</td>
</tr>
<tr>
<td><code>description</code></td>
<td>边的标签（如”引出”、”属于”）</td>
</tr>
<tr>
<td><code>weight</code></td>
<td>权重值（如关系强度）</td>
</tr>
<tr>
<td><code>combined_degree</code></td>
<td>综合度量（可选）</td>
</tr>
<tr>
<td><code>text_unit_ids</code></td>
<td>来源文本ID集合</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-从-Parquet-到-GraphML-的字段映射关系"><a href="#2-从-Parquet-到-GraphML-的字段映射关系" class="headerlink" title="2. 从 Parquet 到 GraphML 的字段映射关系"></a>2. 从 Parquet 到 GraphML 的字段映射关系</h2><h3 id="1-entities-parquet-→-GraphML-节点（node）"><a href="#1-entities-parquet-→-GraphML-节点（node）" class="headerlink" title="1. entities.parquet → GraphML 节点（node）"></a>1. <code>entities.parquet</code> → GraphML 节点（node）</h3><table>
<thead>
<tr>
<th><code>.parquet</code> 字段</th>
<th>GraphML中映射内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td><code>node id</code></td>
<td>节点的唯一标识，GraphML 中 <code>&lt;node id=&quot;...&quot;&gt;</code></td>
</tr>
<tr>
<td><code>title</code></td>
<td><code>label</code>（属性）</td>
<td>节点显示标签</td>
</tr>
<tr>
<td><code>type</code></td>
<td><code>type</code>（属性）</td>
<td>节点类型</td>
</tr>
<tr>
<td><code>description</code></td>
<td><code>description</code>（属性）</td>
<td>节点的文本描述</td>
</tr>
<tr>
<td><code>text_unit_ids</code></td>
<td><code>text_unit_ids</code>（属性）</td>
<td>来源文本段落 ID</td>
</tr>
<tr>
<td><code>frequency</code></td>
<td><code>frequency</code>（属性）</td>
<td>出现频率（可选）</td>
</tr>
<tr>
<td><code>degree</code></td>
<td><code>degree</code>（属性）</td>
<td>图中连接度（可选）</td>
</tr>
<tr>
<td><code>x</code>, <code>y</code></td>
<td><code>x</code>, <code>y</code>（属性）</td>
<td>可视化坐标位置（可选）</td>
</tr>
</tbody></table>
<h3 id="2-relationships-parquet-→-GraphML-边（edge）"><a href="#2-relationships-parquet-→-GraphML-边（edge）" class="headerlink" title="2. relationships.parquet → GraphML 边（edge）"></a>2. <code>relationships.parquet</code> → GraphML 边（edge）</h3><table>
<thead>
<tr>
<th><code>.parquet</code> 字段</th>
<th>GraphML中映射内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>source</code></td>
<td><code>edge source</code></td>
<td>边的起点</td>
</tr>
<tr>
<td><code>target</code></td>
<td><code>edge target</code></td>
<td>边的终点</td>
</tr>
<tr>
<td><code>description</code></td>
<td><code>label</code>（属性）</td>
<td>边的标签</td>
</tr>
<tr>
<td><code>weight</code></td>
<td><code>weight</code>（属性）</td>
<td>边的权重</td>
</tr>
<tr>
<td><code>text_unit_ids</code></td>
<td><code>text_unit_ids</code>（属性）</td>
<td>来源文本 ID</td>
</tr>
<tr>
<td><code>combined_degree</code></td>
<td><code>combined_degree</code>（属性）</td>
<td>综合度量（可选）</td>
</tr>
</tbody></table>
<h3 id="GraphML-输出结构示例"><a href="#GraphML-输出结构示例" class="headerlink" title="GraphML 输出结构示例"></a>GraphML 输出结构示例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">id</span>=<span class="string">&quot;523ff398-4659-461e-810a-1b00e4af85df&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">data</span> <span class="attr">key</span>=<span class="string">&quot;label&quot;</span>&gt;</span>Transformer Model<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">data</span> <span class="attr">key</span>=<span class="string">&quot;type&quot;</span>&gt;</span>Concept<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">data</span> <span class="attr">key</span>=<span class="string">&quot;description&quot;</span>&gt;</span>A deep learning model architecture...<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">data</span> <span class="attr">key</span>=<span class="string">&quot;frequency&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">edge</span> <span class="attr">source</span>=<span class="string">&quot;523ff398-4659-461e-810a-1b00e4af85df&quot;</span> <span class="attr">target</span>=<span class="string">&quot;23a77be7-1b36-4fac-a505-f9424d3dbce2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">data</span> <span class="attr">key</span>=<span class="string">&quot;label&quot;</span>&gt;</span>based on<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">data</span> <span class="attr">key</span>=<span class="string">&quot;weight&quot;</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">edge</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-代码结构与功能解释"><a href="#3-代码结构与功能解释" class="headerlink" title="3. 代码结构与功能解释"></a>3. 代码结构与功能解释</h2><h3 id="文件选择界面"><a href="#文件选择界面" class="headerlink" title="文件选择界面"></a>文件选择界面</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = tk.Tk()</span><br><span class="line">root.withdraw()</span><br><span class="line">entities_path = filedialog.askopenfilename(...)</span><br><span class="line">relations_path = filedialog.askopenfilename(...)</span><br></pre></td></tr></table></figure>
<ul>
<li>利用 <code>tkinter</code> 弹出图形界面，分别选择实体文件和关系文件路径。</li>
<li>若用户未选择文件，则程序中断退出。</li>
</ul>
<h3 id="加载-parquet-文件"><a href="#加载-parquet-文件" class="headerlink" title="加载 parquet 文件"></a>加载 parquet 文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">entities_df = pd.read_parquet(entities_path)</span><br><span class="line">relations_df = pd.read_parquet(relations_path)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>pandas</code> 将 <code>.parquet</code> 文件读取为 <code>DataFrame</code>。</li>
<li>后续操作以 <code>DataFrame</code> 行为单位进行图构建。</li>
</ul>
<h3 id="创建图结构"><a href="#创建图结构" class="headerlink" title="创建图结构"></a>创建图结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G = nx.DiGraph()</span><br></pre></td></tr></table></figure>
<ul>
<li>构建 NetworkX 有向图对象 <code>DiGraph()</code>。</li>
<li>若希望生成无向图，替换为 <code>nx.Graph()</code> 即可。</li>
</ul>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, row <span class="keyword">in</span> entities_df.iterrows():</span><br><span class="line">    G.add_node(row[<span class="string">&quot;id&quot;</span>], label=row[<span class="string">&quot;title&quot;</span>], <span class="built_in">type</span>=row[<span class="string">&quot;type&quot;</span>], description=row[<span class="string">&quot;description&quot;</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历 <code>entities_df</code> 的每一行。</li>
<li>每行数据作为图中的一个节点：<ul>
<li>ID 为 <code>row[&quot;id&quot;]</code></li>
<li>附带属性包括 <code>label</code>, <code>type</code>, <code>description</code></li>
</ul>
</li>
</ul>
<h3 id="添加边"><a href="#添加边" class="headerlink" title="添加边"></a>添加边</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, row <span class="keyword">in</span> relations_df.iterrows():</span><br><span class="line">    G.add_edge(row[<span class="string">&quot;source&quot;</span>], row[<span class="string">&quot;target&quot;</span>], label=row[<span class="string">&quot;description&quot;</span>], weight=row.get(<span class="string">&quot;weight&quot;</span>, <span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历 <code>relationships_df</code> 的每一行。</li>
<li>使用 <code>add_edge(source, target, **attrs)</code> 方式添加有向边。</li>
<li>边的属性包括：<ul>
<li><code>label</code>: 描述关系含义</li>
<li><code>weight</code>: 权重，默认为 1.0</li>
</ul>
</li>
</ul>
<h3 id="导出为-GraphML-文件"><a href="#导出为-GraphML-文件" class="headerlink" title="导出为 GraphML 文件"></a>导出为 GraphML 文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output_path = os.path.join(output_dir, <span class="string">&quot;output.graphml&quot;</span>)</span><br><span class="line">nx.write_graphml(G, output_path, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>设置输出路径到本地 <code>output_graphml/</code> 文件夹中。</li>
<li>利用 <code>networkx.write_graphml()</code> 将图写为 <code>.graphml</code> 文件。</li>
<li>GraphML 是 XML 格式，便于被 Gephi、Cytoscape 等图分析工具读取。</li>
</ul>
<hr>
<h2 id="4-将-GraphML-导入-Gephi-实现可视化"><a href="#4-将-GraphML-导入-Gephi-实现可视化" class="headerlink" title="4. 将 GraphML 导入 Gephi 实现可视化"></a>4. 将 GraphML 导入 Gephi 实现可视化</h2><h3 id="1-下载-Gephi"><a href="#1-下载-Gephi" class="headerlink" title="1. 下载 Gephi"></a>1. 下载 Gephi</h3><p>下载地址：<a href="https://gephi.org/users/download/">https://gephi.org/users/download/</a></p>
<h3 id="2-在-Gephi-中打开转换后的-graphml-文件"><a href="#2-在-Gephi-中打开转换后的-graphml-文件" class="headerlink" title="2. 在 Gephi 中打开转换后的.graphml 文件"></a>2. 在 Gephi 中打开转换后的<code>.graphml</code> 文件</h3><p>点击左上方的 <strong>数据资料</strong>，查看节点与边的信息是否均被正确导入。</p>
<h3 id="3-节点与边的渲染"><a href="#3-节点与边的渲染" class="headerlink" title="3. 节点与边的渲染"></a>3. 节点与边的渲染</h3><ul>
<li>打开 <strong>窗口</strong>, 选择 <strong>外观</strong>。</li>
<li>在 <strong>外观</strong> 中的 <strong>节点</strong> 窗口，点击 <strong>分割</strong> ，选择 <strong>description</strong> 或是 <strong>type</strong> 进行渲染，点击 <strong>应用</strong>。</li>
<li>如果需要节点与边的具体信息被渲染在窗口，根据图中的配置自行处理。</li>
</ul>
<p><img src="https://github.com/user-attachments/assets/8a2cfa7c-de43-4200-a7f4-74d2e0b57f7b" alt="image"></p>
<hr>
<p>该项目代码参考 <a href="https://github.com/microsoft/graphrag.git">GraphRag</a>。</p>
]]></content>
      <categories>
        <category>Knowledge Graph</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大模型</tag>
        <tag>Knowledge Graph</tag>
        <tag>Python</tag>
        <tag>GraphRAG</tag>
        <tag>RAG</tag>
        <tag>Gephi</tag>
      </tags>
  </entry>
  <entry>
    <title>NebulaGraphQAChain</title>
    <url>/2025/03/20/NebulaGraphQAChain/</url>
    <content><![CDATA[<h1 id="基于Langchain在NebulaGraph实现GraphRAG"><a href="#基于Langchain在NebulaGraph实现GraphRAG" class="headerlink" title="基于Langchain在NebulaGraph实现GraphRAG"></a>基于Langchain在NebulaGraph实现GraphRAG</h1><hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/NebulaGraphQAChain.git">https://github.com/EvannZhongg/NebulaGraphQAChain.git</a></p>
<hr>
<h2 id="1-这个代码是做什么的？"><a href="#1-这个代码是做什么的？" class="headerlink" title="1. 这个代码是做什么的？"></a><strong>1. 这个代码是做什么的？</strong></h2><ul>
<li><strong>把自然语言问题转化为图数据库NebulaGraph查询语句</strong></li>
<li><strong>查询 NebulaGraph（确保图数据库中已经存在数据，本代码不再额外构建数据插入图数据库）</strong></li>
<li><strong>返回查询结果</strong></li>
</ul>
<p><strong>简单来说</strong>：<br>你可以用“人话”问它问题，它会自动 <strong>翻译成图数据库语言</strong>，然后去 <strong>图数据库找答案</strong>，将查询到的结果与提问相结合重新用“人话”回答问题。</p>
<hr>
<h2 id="2-代码执行的流程是什么？"><a href="#2-代码执行的流程是什么？" class="headerlink" title="2. 代码执行的流程是什么？"></a><strong>2. 代码执行的流程是什么？</strong></h2><ol>
<li>读取 <strong>API 配置</strong>（告诉代码如何访问 LLM）</li>
<li>调用 <strong>大模型（LLM）</strong>，让它帮我们翻译问题</li>
<li>连接 <strong>NebulaGraph</strong> 数据库</li>
<li>执行 <strong>数据库查询</strong>，获得结果</li>
<li>返回最终的查询结果</li>
</ol>
<hr>
<h2 id="3-代码分解讲解"><a href="#3-代码分解讲解" class="headerlink" title="3. 代码分解讲解"></a><strong>3. 代码分解讲解</strong></h2><h3 id="3-1-读取环境变量（API-配置）"><a href="#3-1-读取环境变量（API-配置）" class="headerlink" title="3.1 读取环境变量（API 配置）"></a><strong>3.1 读取环境变量（API 配置）</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 .env 文件</span></span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line">CHAT_API_URL = os.getenv(<span class="string">&quot;CHAT_API_URL&quot;</span>)</span><br><span class="line">API_KEY = os.getenv(<span class="string">&quot;API_KEY&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> CHAT_API_URL <span class="keyword">or</span> <span class="keyword">not</span> API_KEY:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&quot;请在 .env 文件中正确配置 CHAT_API_URL 和 API_KEY&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用：</strong></h4><ul>
<li><strong>读取 API 地址</strong> 和 <strong>密钥</strong>，让代码知道如何访问大模型。</li>
<li><strong>如果没有配置 API</strong>，就会报错，提醒用户。</li>
</ul>
<p>🔹 <strong>什么是 .env 文件？</strong></p>
<p><code>.env</code> 文件用于存放 <strong>API 密钥</strong>，这样我们就不用在代码里写明白，保证安全，你可以在项目目录中新建一个<code>.env</code> 文件，本文使用的是siliconflow平台提供的API服务，你可以在siliconflow平台进行注册申请API KEY填入下方的<code>API_KEY</code>变量中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CHAT_API_URL=https://api.siliconflow.cn/v1/chat/completions</span><br><span class="line">API_KEY=sk-***************************</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-2-调用-LLM-API"><a href="#3-2-调用-LLM-API" class="headerlink" title="3.2 调用 LLM API"></a><strong>3.2 调用 LLM API</strong></h3><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">call_chat_api</span>(<span class="params">prompt</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    调用 LLM API 生成 Cypher 查询</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(</span><br><span class="line">            CHAT_API_URL,</span><br><span class="line">            headers=&#123;<span class="string">&quot;Authorization&quot;</span>: <span class="string">f&quot;Bearer <span class="subst">&#123;API_KEY&#125;</span>&quot;</span>&#125;,</span><br><span class="line">            json=&#123;</span><br><span class="line">                <span class="string">&quot;model&quot;</span>: <span class="string">&quot;deepseek-ai/DeepSeek-V3&quot;</span>,  <span class="comment"># 选择模型</span></span><br><span class="line">                <span class="string">&quot;messages&quot;</span>: [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            data = response.json()</span><br><span class="line">            result = data[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;message&quot;</span>][<span class="string">&quot;content&quot;</span>]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理 Markdown 代码块</span></span><br><span class="line">            <span class="keyword">if</span> result.startswith(<span class="string">&quot;```nebula&quot;</span>) <span class="keyword">and</span> result.endswith(<span class="string">&quot;```&quot;</span>):</span><br><span class="line">                result = result[<span class="built_in">len</span>(<span class="string">&quot;```nebula&quot;</span>):-<span class="built_in">len</span>(<span class="string">&quot;```&quot;</span>)].strip()</span><br><span class="line">            <span class="keyword">elif</span> result.startswith(<span class="string">&quot;```cypher&quot;</span>) <span class="keyword">and</span> result.endswith(<span class="string">&quot;```&quot;</span>):</span><br><span class="line">                result = result[<span class="built_in">len</span>(<span class="string">&quot;```cypher&quot;</span>):-<span class="built_in">len</span>(<span class="string">&quot;```&quot;</span>)].strip()</span><br><span class="line">            <span class="keyword">elif</span> result.startswith(<span class="string">&quot;```sql&quot;</span>) <span class="keyword">and</span> result.endswith(<span class="string">&quot;```&quot;</span>):</span><br><span class="line">                result = result[<span class="built_in">len</span>(<span class="string">&quot;```sql&quot;</span>):-<span class="built_in">len</span>(<span class="string">&quot;```&quot;</span>)].strip()</span><br><span class="line">            <span class="keyword">elif</span> result.startswith(<span class="string">&quot;```&quot;</span>) <span class="keyword">and</span> result.endswith(<span class="string">&quot;```&quot;</span>):</span><br><span class="line">                result = result[<span class="built_in">len</span>(<span class="string">&quot;```&quot;</span>):-<span class="built_in">len</span>(<span class="string">&quot;```&quot;</span>)].strip()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;API 调用失败: <span class="subst">&#123;response.status_code&#125;</span> <span class="subst">&#123;response.text&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;API 调用出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a><strong>作用：</strong></h4><ol>
<li><strong>发送请求</strong> 给 LLM（大模型），让它把用户问题翻译成 <strong>数据库查询语句</strong>。</li>
<li><strong>解析返回结果</strong>，提取真正的数据库查询语句。</li>
<li><strong>如果出错</strong>，就打印错误信息。</li>
</ol>
<ul>
<li>代码中的以下部分用于处理大模型输出含有代码标记块的情况，如果你的大模型输出含有代码标记块则查询语句会出现失败，在下方代码中添加代码标记块名称，避免查询出错.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if result.startswith(&quot;```代码标记块内容&quot;) and result.endswith(&quot;```&quot;):</span><br><span class="line">  result = result[len(&quot;```&quot;):-len(&quot;```&quot;)].strip()</span><br></pre></td></tr></table></figure></li>
</ul>
<p> <strong>示例：</strong></p>
<ul>
<li>你输入：“列出某个电子器件的所有相关参数”</li>
<li>LLM 可能返回：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MATCH (n:Component) RETURN n.parameters</span><br></pre></td></tr></table></figure>
这个就是 <strong>Cypher 查询语句</strong>，可以直接在图数据库执行。</li>
</ul>
<hr>
<h3 id="3-3-自定义-LLM-处理类生成查询语句"><a href="#3-3-自定义-LLM-处理类生成查询语句" class="headerlink" title="3.3 自定义 LLM 处理类生成查询语句"></a><strong>3.3 自定义 LLM 处理类生成查询语句</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.runnables <span class="keyword">import</span> Runnable</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompt_values <span class="keyword">import</span> StringPromptValue</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomChatModel</span>(<span class="title class_ inherited__">Runnable</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self, <span class="built_in">input</span>, config: <span class="built_in">dict</span> = <span class="literal">None</span>, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(<span class="built_in">input</span>, StringPromptValue):</span><br><span class="line">            <span class="built_in">input</span> = <span class="built_in">input</span>.to_string()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(<span class="built_in">input</span>, <span class="built_in">str</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;Expected input to be a string, got <span class="subst">&#123;<span class="built_in">type</span>(<span class="built_in">input</span>)&#125;</span> instead.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        result = call_chat_api(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;API 调用未返回有效响应&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a><strong>作用：</strong></h4><ul>
<li>让 <strong>LangChain 框架</strong> 知道如何调用 LLM。</li>
<li>处理输入数据，确保 LLM <strong>可以正确理解问题</strong>。</li>
<li>调用 <code>call_chat_api()</code>，获取 LLM 生成的数据库查询语句。</li>
</ul>
<hr>
<h3 id="3-4-连接-NebulaGraph"><a href="#3-4-连接-NebulaGraph" class="headerlink" title="3.4 连接 NebulaGraph"></a><strong>3.4 连接 NebulaGraph</strong></h3><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a><strong>代码：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_community.graphs <span class="keyword">import</span> NebulaGraph</span><br><span class="line"></span><br><span class="line">graph = NebulaGraph(</span><br><span class="line">    space=<span class="string">&quot;SPACE&quot;</span>,  <span class="comment">#将SPACE修改为自己的图空间名称</span></span><br><span class="line">    username=<span class="string">&quot;root&quot;</span>,</span><br><span class="line">    password=<span class="string">&quot;nebula&quot;</span>,</span><br><span class="line">    address=<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    port=<span class="number">9669</span>,</span><br><span class="line">    session_pool_size=<span class="number">30</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="作用：-3"><a href="#作用：-3" class="headerlink" title="作用："></a><strong>作用：</strong></h4><ul>
<li>连接 <strong>NebulaGraph 图数据库</strong>，让代码可以查询数据。</li>
<li>配置 <strong>数据库地址、用户名、密码</strong>。</li>
</ul>
<hr>
<h3 id="3-5-运行查询示例"><a href="#3-5-运行查询示例" class="headerlink" title="3.5 运行查询示例"></a><strong>3.5 运行查询示例</strong></h3><h4 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a><strong>代码：</strong></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">query_graph</span>(<span class="params">question</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    运行 NebulaGraph QAChain，处理自然语言查询</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        answer = chain.run(question)</span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;查询执行出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test_question = <span class="built_in">input</span>(<span class="string">&quot;请输入您的查询问题: &quot;</span>)  <span class="comment"># 让用户在终端输入问题</span></span><br><span class="line">    response = query_graph(test_question)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;查询结果:&quot;</span>, response)</span><br></pre></td></tr></table></figure>
<h4 id="作用：-4"><a href="#作用：-4" class="headerlink" title="作用："></a><strong>作用：</strong></h4><ul>
<li>让用户输入问题。</li>
<li>调用 <code>chain.run(question)</code> 处理查询。</li>
<li><strong>返回查询语句和结果</strong>。</li>
</ul>
<p>📌 <strong>示例：</strong></p>
<ol>
<li>用户输入：<strong>“1N4736AT-D的应用有什么”</strong></li>
<li>代码调用 LLM，获取 Cypher 语句</li>
<li>执行数据库查询，返回结果。<br><img src="https://github.com/user-attachments/assets/fefb7d40-9737-4dc1-a3d0-266445ccc65a" alt="Query Execution"></li>
<li>我们可以在图数据库中进行验证。<br><img src="https://github.com/user-attachments/assets/72b07b88-740e-4210-aaaf-823e29bfb3d1" alt="Nebula Graph Query"></li>
<li>这里制作了一个简易的前端页面，可以查看效果和后端日志，详细代码可在本文开头的项目地址中获取。<br><img src="https://github.com/user-attachments/assets/8a1613eb-ec9a-4e2f-bce9-3876ebc80191" alt="image"></li>
</ol>
<hr>
<p>该项目代码参考 <a href="https://github.com/hwchase17/langchain">LangChain</a> 和 <a href="http://doc.cnlangchain.com/modules/chains/examples/graph_nebula_qa.html">NebulaGraphQAChain</a>。</p>
]]></content>
      <categories>
        <category>Knowledge Graph</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大模型</tag>
        <tag>Knowledge Graph</tag>
        <tag>Python</tag>
        <tag>GraphRAG</tag>
        <tag>RAG</tag>
        <tag>图数据库</tag>
        <tag>LangChain</tag>
        <tag>NebulaGraph</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo and Chic themes add Giscus comment system</title>
    <url>/2025/03/24/Hexo-and-Chic-themes-add-Giscus-comment-system/</url>
    <content><![CDATA[<h1 id="Hexo-Chic-主题集成-Giscus-评论系统详细教程"><a href="#Hexo-Chic-主题集成-Giscus-评论系统详细教程" class="headerlink" title="Hexo + Chic 主题集成 Giscus 评论系统详细教程"></a>Hexo + Chic 主题集成 Giscus 评论系统详细教程</h1><p>本教程将教你如何在 Hexo 博客（使用 Chic 主题）中添加 Giscus 评论系统，让你的博客拥有简洁现代的评论功能，并且支持明暗模式自动切换。</p>
<hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Blog-Learning.git">https://github.com/EvannZhongg/Blog-Learning.git</a></p>
<hr>
<h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="1-确保你已完成以下条件："><a href="#1-确保你已完成以下条件：" class="headerlink" title="1. 确保你已完成以下条件："></a>1. 确保你已完成以下条件：</h3><ul>
<li>博客已搭建并使用 Hexo 框架</li>
<li>正在使用 <a href="https://github.com/Siricee/hexo-theme-Chic.git">hexo-theme-Chic</a> 主题</li>
<li>博客托管在 GitHub</li>
</ul>
<h3 id="2-启用-GitHub-Discussions-功能"><a href="#2-启用-GitHub-Discussions-功能" class="headerlink" title="2. 启用 GitHub Discussions 功能"></a>2. 启用 GitHub Discussions 功能</h3><ol>
<li>打开你的博客仓库页面</li>
<li>点击顶部的 <strong>Settings</strong></li>
<li>在 <strong>General</strong> 中 <strong>Features</strong> 区域点击 <strong>Discussions</strong></li>
<li>勾选 <strong>“Enable discussions for this repository”</strong></li>
</ol>
<p><img src="https://github.com/user-attachments/assets/6686f60e-f2d4-4a87-8b0d-d3425070c2cd" alt="setting_discussions"></p>
<hr>
<h2 id="二、使用-Giscus-app-获取评论配置代码"><a href="#二、使用-Giscus-app-获取评论配置代码" class="headerlink" title="二、使用 Giscus.app 获取评论配置代码"></a>二、使用 Giscus.app 获取评论配置代码</h2><ol>
<li>打开 Giscus 官网：<a href="https://giscus.app/">https://giscus.app</a></li>
<li>登录 GitHub 账号</li>
<li>安装 <a href="https://github.com/apps/giscus">giscus</a> app  ，否则访客将无法评论和回应</li>
<li>按照如下选择进行配置：<ul>
<li>Repository: 选择你的博客仓库（注意填写格式为 <strong>用户名&#x2F;仓库名</strong>）</li>
<li>Discussion Category: 建议选择 <strong>Announcements</strong>（防止读者随意发帖）</li>
<li>Page ↔️ Discussion Mapping: 选择 <strong>pathname</strong></li>
<li>Theme: 选择任意（我们后续会动态控制）</li>
<li>Language: 选择 <code>zh-CN</code></li>
</ul>
</li>
<li>点击页面底部的 <strong>“Copy code snippet”</strong>，复制生成的 <code>&lt;script&gt;</code> 标签代码</li>
</ol>
<hr>
<h2 id="三、创建评论模块文件"><a href="#三、创建评论模块文件" class="headerlink" title="三、创建评论模块文件"></a>三、创建评论模块文件</h2><h3 id="1-打开博客主题目录"><a href="#1-打开博客主题目录" class="headerlink" title="1. 打开博客主题目录"></a>1. 打开博客主题目录</h3><p>路径：<code>themes/hexo-theme-Chic/layout/_partial/</code></p>
<h3 id="2-创建或编辑-livers-ejs-文件"><a href="#2-创建或编辑-livers-ejs-文件" class="headerlink" title="2. 创建或编辑 livers.ejs 文件"></a>2. 创建或编辑 <code>livers.ejs</code> 文件</h3><p>将 Giscus 中生成的 <code>&lt;script&gt;</code> 标签代码填入文件（注意部分参数的区别），同时增加主题自动同步功能代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Giscus 评论区挂载点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;giscus-container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 2.5rem;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Giscus 动态加载脚本：初始加载 + 明暗主题切换 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">createGiscus</span>(<span class="params">theme</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> giscusContainer = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;giscus-container&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (!giscusContainer) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 清除旧的评论 iframe</span></span></span><br><span class="line"><span class="language-javascript">    giscusContainer.<span class="property">innerHTML</span> = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    script.<span class="property">src</span> = <span class="string">&#x27;https://giscus.app/client.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 替换为你的 GitHub 仓库信息（格式：username/repo）</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-repo&#x27;</span>, <span class="string">&#x27;your-github-username/your-repo-name&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 替换为你的 repo-id 和 category-id（在 giscus.app 配置页面生成）</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-repo-id&#x27;</span>, <span class="string">&#x27;your-repo-id&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-category&#x27;</span>, <span class="string">&#x27;your-category-name&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-category-id&#x27;</span>, <span class="string">&#x27;your-category-id&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 其他常规推荐设置</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-mapping&#x27;</span>, <span class="string">&#x27;pathname&#x27;</span>);           <span class="comment">// 用页面路径匹配评论帖</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-strict&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);                   <span class="comment">// 若无匹配帖则创建新帖</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-reactions-enabled&#x27;</span>, <span class="string">&#x27;1&#x27;</span>);        <span class="comment">// 启用表情反应</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-emit-metadata&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);            <span class="comment">// 不输出元数据</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-input-position&#x27;</span>, <span class="string">&#x27;top&#x27;</span>);         <span class="comment">// 输入框在评论上方</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-theme&#x27;</span>, theme);                </span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-lang&#x27;</span>, <span class="string">&#x27;zh-CN&#x27;</span>);                 <span class="comment">// 中文界面</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="title function_">setAttribute</span>(<span class="string">&#x27;crossorigin&#x27;</span>, <span class="string">&#x27;anonymous&#x27;</span>);           <span class="comment">// 跨域资源安全</span></span></span><br><span class="line"><span class="language-javascript">    script.<span class="property">async</span> = <span class="literal">true</span>;                                       </span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">    giscusContainer.<span class="title function_">appendChild</span>(script);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">getCurrentTheme</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;dark-theme&#x27;</span>) ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 页面首次加载，根据当前主题挂载评论</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">createGiscus</span>(<span class="title function_">getCurrentTheme</span>());</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听按钮点击切换主题 → 重载评论区</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> buttons = [</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.toggleBtn&#x27;</span>),</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mobile-toggle-theme&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    ];</span></span><br><span class="line"><span class="language-javascript">    buttons.<span class="title function_">forEach</span>(<span class="function"><span class="params">btn</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (!btn) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">      btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">createGiscus</span>(<span class="title function_">getCurrentTheme</span>());</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">400</span>); <span class="comment">// 稍作延迟，确保 class 切换完毕</span></span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听 body class 改变（保险方案）</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">createGiscus</span>(<span class="title function_">getCurrentTheme</span>());</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123; <span class="attr">attributes</span>: <span class="literal">true</span>, <span class="attr">attributeFilter</span>: [<span class="string">&#x27;class&#x27;</span>] &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 请将 <code>data-repo-id</code> 和 <code>data-category-id</code> 替换为你从 giscus.app 获取的值。</p>
</blockquote>
<hr>
<h2 id="四、引入评论模块到文章模板"><a href="#四、引入评论模块到文章模板" class="headerlink" title="四、引入评论模块到文章模板"></a>四、引入评论模块到文章模板</h2><p>打开文件：<code>themes/hexo-theme-Chic/layout/_page/post.ejs</code></p>
<p>找到代码底部，在 <code>&lt;/article&gt;</code> 上方添加一行代码 <code>&lt;%- partial(&#39;_partial/livers&#39;) %&gt;</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        &lt;section class=&quot;post-nav&quot;&gt;</span><br><span class="line">            &lt;% if(post.prev)&#123; %&gt;</span><br><span class="line">                &lt;a class=&quot;prev&quot; rel=&quot;prev&quot; href=&quot;&lt;%- url_for(post.prev.path)%&gt;&quot;&gt;&lt;%- post.prev.title%&gt;&lt;/a&gt;</span><br><span class="line">            &lt;% &#125; %&gt;</span><br><span class="line">            &lt;% if(post.next)&#123; %&gt;</span><br><span class="line">            &lt;a class=&quot;next&quot; rel=&quot;next&quot; href=&quot;&lt;%- url_for(post.next.path)%&gt;&quot;&gt;&lt;%- post.next.title%&gt;&lt;/a&gt;</span><br><span class="line">            &lt;% &#125; %&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line"></span><br><span class="line">	&lt;%- partial(&#x27;_partial/livers&#x27;) %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/article&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这会让评论区出现在每篇文章的底部。</p>
<hr>
<h2 id="五、重新部署博客"><a href="#五、重新部署博客" class="headerlink" title="五、重新部署博客"></a>五、重新部署博客</h2><p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>然后访问你的博客文章页面，应该就能看到 Giscus 评论框</p>
<hr>
<h2 id="成功效果"><a href="#成功效果" class="headerlink" title="成功效果"></a>成功效果</h2><p><img src="https://github.com/user-attachments/assets/b75a7ffd-d99b-4d4a-9e95-cb43b06b36aa" alt="discussions"> </p>
<ul>
<li>支持 GitHub 登录评论</li>
<li>评论存储在 Discussions 中，便于管理</li>
<li>评论区支持明暗主题自动切换，与 Chic 博客风格一致</li>
</ul>
<hr>
<p>如有问题，可以：</p>
<ul>
<li>检查浏览器控制台是否有加载错误</li>
<li>确保 repo-id 和 category-id 正确</li>
<li>确保启用了 Discussions 功能</li>
</ul>
<hr>
<p>该项目代码基于 <a href="https://github.com/hexojs/hexo.git">Hexo</a> 和 <a href="https://github.com/Siricee/hexo-theme-Chic.git">hexo-theme-Chic</a> 。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Securely Rendering LLM-Generated Local Image Paths in Flask</title>
    <url>/2025/06/13/Securely-Rendering-LLM-Generated-Local-Image-Paths-in-Flask/</url>
    <content><![CDATA[<h1 id="一个在Flask-Web应用中安全渲染LLM输出的本地图片路径的方法"><a href="#一个在Flask-Web应用中安全渲染LLM输出的本地图片路径的方法" class="headerlink" title="一个在Flask Web应用中安全渲染LLM输出的本地图片路径的方法"></a>一个在Flask Web应用中安全渲染LLM输出的本地图片路径的方法</h1><h2 id="1-问题背景：浏览器安全模型与本地文件访问限制"><a href="#1-问题背景：浏览器安全模型与本地文件访问限制" class="headerlink" title="1. 问题背景：浏览器安全模型与本地文件访问限制"></a>1. 问题背景：浏览器安全模型与本地文件访问限制</h2><p>在构建基于大型语言模型（<code>LLM</code>）的 <code>Web</code> 应用时，一个常见的场景是 <code>LLM</code> 的输出中包含了指向服务器本地文件系统的图片路径。例如，在一个本地搭建的 <code>RAG</code> 系统中，<code>LLM</code> 可能会根据上下文生成一段包含标准 <code>Markdown</code> 图片语法的回答：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片](D:\images\image.png)</span><br></pre></td></tr></table></figure>
<p>然而，如果将这段 <code>Markdown</code> 直接转换为 <code>HTML</code>（例如 <code>&lt;img src=&quot;D:\project\data\images\package_diagram.png&quot;&gt;</code>），并试图在用户浏览器中渲染，该请求将会失败出现报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not allowed to load local resource: file:///D:/...</span><br></pre></td></tr></table></figure>
<p>这是因为现代浏览器的安全模型，特别是同源策略（<code>Same-Origin Policy</code>）和安全沙箱机制，严格禁止网页中的JavaScript代码直接访问用户的本地或远程服务器的任意文件系统。这种限制是保障用户安全的基石。</p>
<p>因此，必须设计一个安全且有效的机制，作为浏览器和服务器文件系统之间的“中间人”，以实现图片的正确渲染。</p>
<hr>
<h2 id="2-解决方案架构：建立一个“受信任的中间人”"><a href="#2-解决方案架构：建立一个“受信任的中间人”" class="headerlink" title="2. 解决方案架构：建立一个“受信任的中间人”"></a>2. 解决方案架构：建立一个“受信任的中间人”</h2><p>既然前端浏览器不能直接去服务器硬盘上“拿”图片，我们就需要一个“中间人”来代劳。这个中间人必须是服务器自己，因为服务器有权限访问自己的文件系统。</p>
<p>这个思路引出了一种经典的架构模式：代理服务（<code>Proxy Service</code>）。</p>
<p>我们的方法论可以分解为以下几个步骤：</p>
<ul>
<li><p><strong>约定一个暗号</strong>：前端和后端约定一个特殊的 <code>URL</code> 格式，作为请求图片的“暗号”。这个 <code>URL</code> 不会暴露真实的文件路径，而是指向我们即将创建的后端服务。</p>
</li>
<li><p><strong>创建后端代理端点</strong>：在 <code>Flask</code> 中创建一个 <code>API</code> 端点（例如 <code>/image</code>）。这个端点是唯一有权访问服务器上特定图片目录的“守门人”。</p>
</li>
<li><p><strong>前端发起代理请求</strong>：当前端需要显示一张本地图片时，它不直接使用文件路径，而是向这个 <code>/image</code> 端点发起一个请求，并将真实的文件路径作为参数传递。</p>
</li>
<li><p><strong>后端验证并服务</strong>：后端代理收到请求后，首先进行严格的安全检查，确保请求的路径是合法的。验证通过后，它才去硬盘上读取图片文件。</p>
</li>
<li><p><strong>安全的数据传输</strong>：后端不直接发送文件，而是将图片内容编码为 <code>Base64</code> 字符串。这是一种能将二进制数据转换为纯文本的编码方式，非常适合在 <code>JSON</code> 中传输。</p>
</li>
<li><p><strong>前端动态渲染</strong>：前端接收到包含Base64数据的JSON后，用这些数据动态地构建一个 <code>Data URL</code> ，并将其赋给 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性，最终将图片显示出来。</p>
</li>
</ul>
<p>这个流程的核心在于，将一个不安全的直接文件访问，转变为一个安全的、受控的 <code>API</code> 调用。</p>
<hr>
<h2 id="3-代码实现详解"><a href="#3-代码实现详解" class="headerlink" title="3. 代码实现详解"></a>3. 代码实现详解</h2><h3 id="3-1-后端-app-py-构建安全的文件代理与Base64编码器"><a href="#3-1-后端-app-py-构建安全的文件代理与Base64编码器" class="headerlink" title="3.1. 后端 (app.py): 构建安全的文件代理与Base64编码器"></a>3.1. 后端 (app.py): 构建安全的文件代理与Base64编码器</h3><p>核心改动是在Flask应用中增加 <code>/image</code> 路由。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import base64</span><br><span class="line">from flask import Flask, jsonify, request, abort</span><br><span class="line"></span><br><span class="line"># ... (其他Flask应用设置) ...</span><br><span class="line"></span><br><span class="line"># 1. 定义一个安全的根目录，所有图片请求都必须在此目录之下</span><br><span class="line">#    为安全起见，请将此路径设置为您的项目根目录或包含所有图片的特定父目录。</span><br><span class="line">#    os.getcwd() 会获取当前脚本运行的目录，这是一个安全的默认值。</span><br><span class="line">IMAGE_BASE_DIR = os.path.abspath(os.getcwd())</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/image&#x27;)</span><br><span class="line">def serve_image():</span><br><span class="line">    # 2. 获取前端通过URL参数传来的路径</span><br><span class="line">    image_path = request.args.get(&#x27;path&#x27;)</span><br><span class="line"></span><br><span class="line">    # 3. 安全校验：确保请求的路径没有“越界”</span><br><span class="line">    safe_path = os.path.abspath(image_path)</span><br><span class="line">    if not safe_path.startswith(IMAGE_BASE_DIR):</span><br><span class="line">        abort(403) # 拒绝非法请求</span><br><span class="line"></span><br><span class="line">    # 4. 读取文件并编码为Base64</span><br><span class="line">    try:</span><br><span class="line">        with open(safe_path, &quot;rb&quot;) as image_file:</span><br><span class="line">            encoded_string = base64.b64encode(image_file.read()).decode(&#x27;utf-8&#x27;)</span><br><span class="line">        </span><br><span class="line">        # 5. 构造包含MIME类型和编码数据的Data URL</span><br><span class="line">        ext = os.path.splitext(safe_path)[1].lower()</span><br><span class="line">        mime_type = &#123;&#x27;.png&#x27;: &#x27;image/png&#x27;, &#x27;.jpg&#x27;: &#x27;image/jpeg&#x27;&#125;.get(ext, &#x27;application/octet-stream&#x27;)</span><br><span class="line">        data_url = f&quot;data:&#123;mime_type&#125;;base64,&#123;encoded_string&#125;&quot;</span><br><span class="line"></span><br><span class="line">        # 6. 将Data URL打包成JSON返回</span><br><span class="line">        return jsonify(&#123;&quot;imageData&quot;: data_url&#125;)</span><br><span class="line">    except FileNotFoundError:</span><br><span class="line">        abort(404)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        abort(500)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>安全检查: <code>IMAGE_BASE_DIR</code> 的设置和 <code>startswith()</code> 的验证是此端点的安全核心，它将文件访问权限严格限制在预设的目录范围内。</p>
</li>
<li><p>Base64编码: 将图片转换为 <code>Base64</code> 格式的 <code>Data URL</code>，允许图片数据作为文本嵌入到 <code>JSON</code> 响应中，并能被浏览器直接渲染，避免了前端需要为获取图片而发起额外的 <code>HTTP</code> 请求。</p>
</li>
</ul>
<hr>
<h3 id="3-2-前端-index-html-自定义Markdown渲染与异步加载"><a href="#3-2-前端-index-html-自定义Markdown渲染与异步加载" class="headerlink" title="3.2. 前端 (index.html): 自定义Markdown渲染与异步加载"></a>3.2. 前端 (index.html): 自定义Markdown渲染与异步加载</h3><p>前端的核心工作在 <code>appendAiMessage</code> 函数中，通过重写 <code>marked.js</code> 的图片渲染逻辑来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function appendAiMessage(data, fullLog = &#x27;&#x27;) &#123;</span><br><span class="line">    // ... (其他创建消息元素的代码) ...</span><br><span class="line">    const messageDiv = document.createElement(&#x27;div&#x27;);</span><br><span class="line">    </span><br><span class="line">    // --- 1. 自定义Markdown图片渲染规则 ---</span><br><span class="line">    const renderer = new marked.Renderer();</span><br><span class="line">    renderer.image = (href, title, text) =&gt; &#123;</span><br><span class="line">        // 安全检查，确保href是字符串</span><br><span class="line">        if (typeof href !== &#x27;string&#x27;) &#123;</span><br><span class="line">            console.error(&quot;marked.js renderer received a non-string href:&quot;, href);</span><br><span class="line">            return &#x27;&#x27;; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const decodedHref = decodeURIComponent(href || &#x27;&#x27;);</span><br><span class="line">        </span><br><span class="line">        // 使用正则表达式检查是否是需要代理的本地绝对路径</span><br><span class="line">        if (/^[a-zA-Z]:[\\\/]/.test(decodedHref)) &#123;</span><br><span class="line">            const encodedPath = encodeURIComponent(decodedHref);</span><br><span class="line">            // **步骤 A (生成占位符)**: 返回一个&lt;img&gt;标签，其src指向后端的/image代理API</span><br><span class="line">            return &#x27;&lt;img src=&quot;/image?path=&#x27; + encodedPath + &#x27;&quot; alt=&quot;&#x27; + (text || &#x27;相关图片&#x27;) + &#x27;&quot; style=&quot;opacity: 0.5;&quot;&gt;&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对于标准的网络图片，维持原样</span><br><span class="line">        return &#x27;&lt;img src=&quot;&#x27; + href + &#x27;&quot; alt=&quot;&#x27; + (text || &#x27;&#x27;) + &#x27;&quot;&gt;&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 使用自定义渲染器将Markdown文本转换为HTML</span><br><span class="line">    const htmlContent = marked.parse(answer || &quot;抱歉，没有收到回答。&quot;, &#123; renderer: renderer &#125;);</span><br><span class="line">    messageDiv.innerHTML = htmlContent;</span><br><span class="line">    // ... (将messageDiv添加到聊天窗口) ...</span><br><span class="line"></span><br><span class="line">    // --- 2. 异步获取并替换图片 ---</span><br><span class="line">    // 查找所有需要从后端加载的&quot;占位&quot;图片</span><br><span class="line">    const imagesToLoad = messageDiv.querySelectorAll(&#x27;img[src^=&quot;/image?path=&quot;]&#x27;);</span><br><span class="line">    imagesToLoad.forEach(async (img) =&gt; &#123;</span><br><span class="line">        const placeholderSrc = img.getAttribute(&#x27;src&#x27;);</span><br><span class="line">        if (!placeholderSrc) return;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // **步骤 B (发起代理请求)**: 异步向后端API请求真实的图片数据</span><br><span class="line">            const response = await fetch(placeholderSrc);</span><br><span class="line">            if (!response.ok) throw new Error(&#x27;Failed to fetch image data: &#x27; + response.status);</span><br><span class="line">            const imgData = await response.json(); // 解析后端返回的JSON</span><br><span class="line">            </span><br><span class="line">            // **步骤 C (替换src)**: 将图片的src属性替换为后端返回的Base64 Data URL</span><br><span class="line">            if (imgData.imageData) &#123;</span><br><span class="line">                img.src = imgData.imageData;</span><br><span class="line">                img.style.opacity = 1; // 使图片完全可见</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.error(&#x27;加载图片失败:&#x27;, error);</span><br><span class="line">            img.alt = &quot;图片加载失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // ... (其他代码) ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>渲染逻辑分离: <code>HTML</code> 的初始渲染和图片的最终加载是分离的。<code>marked.js</code> 首先创建了包含代理 <code>URL</code> 的 <code>HTML</code> 结构。</p>
</li>
<li><p>异步非阻塞: 图片的加载过程是异步的，不会阻塞用户界面的其他操作。用户可以立即看到文本内容，而图片会在后台加载完成后显示。</p>
</li>
</ul>
<hr>
<h3 id="3-2-1-正则表达式详解"><a href="#3-2-1-正则表达式详解" class="headerlink" title="3.2.1. 正则表达式详解"></a>3.2.1. 正则表达式详解</h3><p>在前端代码中，用于判断路径是否为本地绝对路径的正则表达式 <code>/^(?:[a-zA-Z]:[\\\/]|\/)/</code> 是一个关键部分。让我们来详细解析它的工作原理：</p>
<ul>
<li><p><code>^</code>: 这个符号代表“字符串的开始”。它确保我们只匹配路径的起始部分，而不是路径中间的某个位置。</p>
</li>
<li><p><code>(?: ... )</code>: 这是一个非捕获组（<code>non-capturing group</code>）。它的作用是将括号内的多个模式组合成一个单元，但不会像普通括号那样“捕获”匹配到的内容。在这里，它将两种主要的路径格式组合在一起。</p>
</li>
<li><p><code>[a-zA-Z]:[\\\/]</code>: 这是用来匹配Windows绝对路径的部分。</p>
</li>
<li><p><code>[a-zA-Z]</code>: 匹配任意一个大写或小写字母（即盘符，如 C, D）。</p>
</li>
<li><p><code>:</code>: 匹配紧跟在盘符后面的冒号。</p>
</li>
<li><p><code>[\\\/]</code>: 匹配一个路径分隔符。\ 是对反斜杠 \ 的转义，&#x2F; 是正斜杠。这个部分意味着无论是 <code>D:\...</code> 还是 <code>D:/...</code>  格式的路径都能被识别。</p>
</li>
<li><p><code>|</code>: 这是一个“或”操作符。它表示匹配左边的模式 或者 右边的模式。</p>
</li>
<li><p><code>/</code>: 这是用来匹配Unix&#x2F;Linux绝对路径的部分。所有Unix-like系统的绝对路径都以一个正斜杠 &#x2F; 开始（例如 <code>/home/user/image.png</code>）。</p>
</li>
</ul>
<hr>
<h2 id="4-对LLM的输出引导"><a href="#4-对LLM的输出引导" class="headerlink" title="4. 对LLM的输出引导"></a>4. 对LLM的输出引导</h2><p>最后一步是确保LLM能够持续生成符合我们预期的、包含本地路径的 <code>Markdown</code> 图片语法。这通过在系统提示（System Prompt）中提供清晰的指令和示例来完成。</p>
<p>指令示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图片处理: 如果一个节点的值是文件路径（例如以 .png, .jpg 等结尾），你应该说“它的封装图如下所示：”或类似的话，然后另起一行，使用标准的Markdown语法 ![封装图](图片路径) 来格式化并展示图片。</span><br></pre></td></tr></table></figure>

<p>成功在前端渲染 <code>markdown</code> 图片效果展示：<br><img src="https://github.com/user-attachments/assets/6241fccf-1ec6-4c52-af78-6b115500ad48" alt="image"></p>
<hr>
<p>该项目代码参考 <a href="https://www.jianshu.com/p/5cc1fff0280c">Not allowed to load local resource: 报错解决方法</a></p>
]]></content>
      <categories>
        <category>LLM学习之路</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>AI</tag>
        <tag>Markdown</tag>
        <tag>LLM</tag>
        <tag>大模型</tag>
        <tag>Python</tag>
        <tag>RAG</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Sync Code Block Theme with Dark Mode in Hexo Chic</title>
    <url>/2025/03/25/Sync-Code-Block-Theme-with-Dark-Mode-in-Hexo-Chic/</url>
    <content><![CDATA[<h1 id="Hexo-Chic-主题为代码块实现明暗主题切换效果"><a href="#Hexo-Chic-主题为代码块实现明暗主题切换效果" class="headerlink" title="Hexo + Chic 主题为代码块实现明暗主题切换效果"></a>Hexo + Chic 主题为代码块实现明暗主题切换效果</h1><p>这份文档记录如何在 Hexo 博客（使用 Chic 主题），完成代码块 (highlight.js) 样式随明&#x2F;暗主题切换。</p>
<hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/Blog-Learning.git">https://github.com/EvannZhongg/Blog-Learning.git</a></p>
<hr>
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><ul>
<li><strong>代码块</strong> 是你写文章时用 &#96;&#96;&#96; 包起来的那些 Python&#x2F;JavaScript 代码部分。</li>
<li><strong>highlight.js</strong> 是用来给代码块加颜色的工具，它有“亮色”和“暗色”两套样式。</li>
</ul>
<p>希望解决的问题是：</p>
<blockquote>
<p>当我切换网站到暗色模式时，代码块还是白底，看起来很突兀。</p>
</blockquote>
<p>我们要做的就是：让代码块也能“跟着变黑”。</p>
<hr>
<h2 id="1-确认-Hexo-正在使用-highlight-js"><a href="#1-确认-Hexo-正在使用-highlight-js" class="headerlink" title="1. 确认 Hexo 正在使用 highlight.js"></a><strong>1. 确认 Hexo 正在使用 highlight.js</strong></h2><p>打开你博客根目录下的 <code>_config.yml</code> 文件，找到下面的内容并确保设置一致：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">syntax_highlighter:</span> <span class="string">highlight.js</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>这段配置的意思是告诉 Hexo：我要用 highlight.js 来做代码高亮。</p>
<hr>
<h2 id="2-修改-head-ejs，引入代码高亮样式"><a href="#2-修改-head-ejs，引入代码高亮样式" class="headerlink" title="2.修改 head.ejs，引入代码高亮样式"></a><strong>2.修改 head.ejs，引入代码高亮样式</strong></h2><p>打开文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes/hexo-theme-Chic/layout/_partial/head.ejs</span><br></pre></td></tr></table></figure>

<p>在里面添加这几行（插入到已有的 <code>&lt;link&gt;</code> 标签之后即可）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- highlight.js 样式（默认亮色） --&gt;</span><br><span class="line">&lt;link id=&quot;hljs-theme&quot; rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.css&quot;&gt;</span><br><span class="line">&lt;!-- highlight.js 自动上色功能 --&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/lib/highlight.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;hljs.highlightAll();&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行是默认代码样式（亮色）。</li>
<li>第二三行是让代码自动加颜色。</li>
</ul>
<hr>
<h2 id="3-修改-script-js，切换暗色样式时动态修改链接"><a href="#3-修改-script-js，切换暗色样式时动态修改链接" class="headerlink" title="3. 修改 script.js，切换暗色样式时动态修改链接"></a><strong>3. 修改 script.js，切换暗色样式时动态修改链接</strong></h2><p>打开文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes/hexo-theme-Chic/source/js/script.js</span><br></pre></td></tr></table></figure>

<p>找到我们添加主题切换的地方，添加以下 JavaScript 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hljsTheme = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hljs-theme&#x27;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateCodeHighlightStyle</span>(<span class="params">isDarkMode</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hljsTheme) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> newHref = isDarkMode</span><br><span class="line">        ? <span class="string">&quot;https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github-dark.css&quot;</span></span><br><span class="line">        : <span class="string">&quot;https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/github.css&quot;</span>;</span><br><span class="line">    hljsTheme.<span class="title function_">setAttribute</span>(<span class="string">&#x27;href&#x27;</span>, newHref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以在主题切换按钮事件里调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">updateCodeHighlightStyle</span>(<span class="literal">true</span>); <span class="comment">// 或 false，根据你当前模式</span></span><br></pre></td></tr></table></figure>

<p>每次切换主题时都调用它，就能切换代码样式。</p>
<hr>
<h2 id="4-创建一个-CSS-文件，解决代码块“白边”问题"><a href="#4-创建一个-CSS-文件，解决代码块“白边”问题" class="headerlink" title="4. 创建一个 CSS 文件，解决代码块“白边”问题"></a><strong>4. 创建一个 CSS 文件，解决代码块“白边”问题</strong></h2><p>这个步骤很关键，否则在暗色样式时代码块周围可能会留下一圈白色边框，如下方图片所示：<br><img src="https://github.com/user-attachments/assets/6baef8c8-887d-448f-a5c9-5f0501ab4ee2" alt="image"></p>
<h3 id="第一步：创建文件夹和文件"><a href="#第一步：创建文件夹和文件" class="headerlink" title="第一步：创建文件夹和文件"></a>第一步：创建文件夹和文件</h3><p>在终端中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd themes/hexo-theme-Chic/source/css</span><br><span class="line">mkdir custom</span><br><span class="line">cd custom</span><br><span class="line">nano custom.css</span><br></pre></td></tr></table></figure>
<p>或者手动：在 <code>themes/hexo-theme-Chic/source/css/</code> 下创建文件夹 <code>custom</code>，然后在里面新建文件 <code>custom.css</code></p>
<h3 id="第二步：填入以下内容："><a href="#第二步：填入以下内容：" class="headerlink" title="第二步：填入以下内容："></a>第二步：填入以下内容：</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">pre,</span><br><span class="line"><span class="selector-tag">code</span>,</span><br><span class="line">pre <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: inherit <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">color</span>: inherit <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dark-theme</span> pre,</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dark-theme</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dark-theme</span> <span class="selector-class">.highlight</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#0d1117</span> <span class="meta">!important</span>;  <span class="comment">/* 暗色背景 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#c9d1d9</span> <span class="meta">!important</span>;       <span class="comment">/* 暗色文字 */</span></span><br><span class="line">    <span class="attribute">box-shadow</span>: none <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.dark-theme</span> pre::-webkit-scrollbar-track,</span><br><span class="line">body.dark-theme code::-webkit-scrollbar-track &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#0d1117</span> <span class="meta">!important</span>;  <span class="comment">/* 修复滚动条白边 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-在-head-ejs-中引入自定义-CSS-文件"><a href="#5-在-head-ejs-中引入自定义-CSS-文件" class="headerlink" title="5. 在 head.ejs 中引入自定义 CSS 文件"></a><strong>5. 在 head.ejs 中引入自定义 CSS 文件</strong></h2><p>在 <code>head.ejs</code> 中再加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%- url_for(&#x27;/css/custom/custom.css&#x27;) %&gt;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>放在其他 <code>&lt;link&gt;</code> 标签的下面。</p>
<hr>
<h2 id="6-重新生成并运行-Hexo"><a href="#6-重新生成并运行-Hexo" class="headerlink" title="6. 重新生成并运行 Hexo"></a><strong>6. 重新生成并运行 Hexo</strong></h2><p>运行以下命令，重新生成并启动本地预览：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>然后访问你的本地博客文章页面 <code>http://localhost:4000</code>，尝试切换主题，看代码块是否也会随之变色。</p>
<p>在两种不同主题下的效果展示：</p>
<p><img src="https://github.com/user-attachments/assets/db87a928-293d-4c00-8299-6619722c92f8" alt="image"></p>
<p><img src="https://github.com/user-attachments/assets/550ba759-3113-41b6-9737-887242fcfa14" alt="image"></p>
<hr>
<p>修改后的相关完整代码可以在文章开头的项目地址中获取</p>
<hr>
<p>该项目代码基于 <a href="https://github.com/hexojs/hexo.git">Hexo</a> 和 <a href="https://github.com/Siricee/hexo-theme-Chic.git">hexo-theme-Chic</a> 。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo AI Assistant</title>
    <url>/2025/03/29/Hexo-AI-Assistant/</url>
    <content><![CDATA[<h1 id="Hexo-博客专属AI助手"><a href="#Hexo-博客专属AI助手" class="headerlink" title="Hexo 博客专属AI助手"></a>Hexo 博客专属AI助手</h1><p>本项目通过向量检索 + 大语言模型（RAG）结合本地 Hexo 博客内容，实现基于语义的智能问答接口。</p>
<hr>
<p>项目地址：<a href="https://github.com/EvannZhongg/hexo-ai-assistant.git">https://github.com/EvannZhongg/hexo-ai-assistant.git</a></p>
<hr>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">📁 D:/YourProjects/</span><br><span class="line">├── 📁 Blog/                       # Hexo 博客项目目录</span><br><span class="line">│   ├── source/_posts/             # Markdown 博文文件目录</span><br><span class="line">│   ├── themes/hexo-theme-xxx/     # 自定义主题目录</span><br><span class="line">│   │   ├── layout/_partial/</span><br><span class="line">│   │   │   ├── footer.ejs         # 向量构建自动化脚本（Hexo 构建钩子）</span><br><span class="line">│   │   │   ├── chatbot.ejs        # ai助手UI</span><br><span class="line">│   │   │   └── ...</span><br><span class="line">│   │   └── ...  </span><br><span class="line">│   ├── scripts/auto_vector.js     # 向量构建自动化脚本（Hexo 构建钩子）</span><br><span class="line">│   └── ...                        # 其他 Hexo 文件</span><br><span class="line">│   </span><br><span class="line">├── 📁 hexo-ai-assistant/          # AI助手后端项目目录</span><br><span class="line">│   ├── build_vector_store.py      # 向量库和标题映射构建脚本</span><br><span class="line">│   ├── main.py                    # Flask 主服务入口（/ask 问答接口）</span><br><span class="line">│   ├── embedder.py                # 嵌入向量生成器（调用第三方 API）</span><br><span class="line">│   ├── chat.py                    # 通用 LLM 聊天模块（OpenAI / DeepSeek）</span><br><span class="line">│   ├── vector_store.json          # 本地语义向量数据库（自动生成）</span><br><span class="line">│   ├── title_mapping.json         # 博客标题与链接映射表（自动生成）</span><br><span class="line">│   ├── config.yml                 # 所有路径、模型、API Key 配置集中管理</span><br><span class="line">│   └── .venv/                     # 虚拟环境（可选）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="执行原理（项目运行流程）"><a href="#执行原理（项目运行流程）" class="headerlink" title="执行原理（项目运行流程）"></a>执行原理（项目运行流程）</h2><ol>
<li><p><strong>语义知识构建阶段</strong>（由 <code>build_vector_store.py</code> 执行）：</p>
<ul>
<li>扫描博客的 Markdown 源文件，提取文章正文内容。</li>
<li>使用嵌入模型（如 BGE）生成语义向量。</li>
<li>构建 <code>vector_store.json</code> 和 <code>title_mapping.json</code>，供问答使用。</li>
</ul>
</li>
<li><p><strong>用户问答处理阶段</strong>（由 <code>main.py</code> 提供 API）：</p>
<ul>
<li>用户通过前端发送提问。</li>
<li>后端提问向量化，与本地向量库匹配最相关文章。</li>
<li>拼接问答上下文（包含语义内容和标题索引）发给大语言模型。</li>
<li>模型生成带参考链接的回答，流式返回至前端。</li>
</ul>
</li>
<li><p><strong>前端问答展示阶段</strong>（由 <code>chat.html</code> &#x2F; <code>chatbot.ejs</code> 负责）：</p>
<ul>
<li>用户界面加载聊天框，支持 Markdown 格式渲染和多轮对话。</li>
<li>请求被代理转发至本地后端或公网中转地址。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1. 安装依赖"></a>1. 安装依赖</h2><p>建议使用虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m venv .venv</span><br><span class="line">.venv\Scripts\activate</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-配置项修改（hexo-ai-assistant-config-yml）"><a href="#2-配置项修改（hexo-ai-assistant-config-yml）" class="headerlink" title="2. 配置项修改（hexo-ai-assistant/config.yml）"></a>2. 配置项修改（<code>hexo-ai-assistant/config.yml</code>）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">paths:</span></span><br><span class="line">  <span class="attr">blog_post_dir:</span> <span class="string">/your/path/to/hexo/source/_posts</span>     <span class="comment"># 修改为你的博客 Markdown 路径</span></span><br><span class="line">  <span class="attr">vector_store:</span> <span class="string">vector_store.json</span>                     <span class="comment"># 向量库保存路径，建议使用绝对路径</span></span><br><span class="line">  <span class="attr">title_mapping:</span> <span class="string">title_mapping.json</span>                   <span class="comment"># 博客标题映射表路径，建议使用绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="attr">blog:</span></span><br><span class="line">  <span class="attr">base_url:</span> <span class="string">https://your-github-pages-url.github.io</span>   <span class="comment"># 修改为你的博客地址（不含末尾 /）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">embedding:</span></span><br><span class="line">  <span class="attr">api_url:</span> <span class="string">https://api.siliconflow.cn/v1/embeddings</span>    <span class="comment"># 嵌入模型 API 地址</span></span><br><span class="line">  <span class="attr">model:</span> <span class="string">BAAI/bge-large-zh-v1.5</span>                         <span class="comment"># 使用的中文嵌入模型</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&lt;YOUR_EMBEDDING_API_KEY&gt;</span>                    <span class="comment"># 替换为你的嵌入模型 API Key</span></span><br><span class="line">  <span class="attr">max_characters:</span> <span class="number">5000</span>                                 <span class="comment"># 每篇文章最大截取字符数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">chat:</span></span><br><span class="line">  <span class="attr">api_url:</span> <span class="string">https://api.deepseek.com/v1</span>                 <span class="comment"># Chat 模型 API 地址（可替换为 OpenAI）</span></span><br><span class="line">  <span class="attr">model:</span> <span class="string">deepseek-chat</span>                                 <span class="comment"># 使用的模型名称</span></span><br><span class="line">  <span class="attr">api_key:</span> <span class="string">&lt;YOUR_CHAT_API_KEY&gt;</span>                         <span class="comment"># 替换为你的 LLM 接口 Key</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span>                                           <span class="comment"># 后端服务运行端口（默认5000）</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-构建向量库-标题映射表"><a href="#3-构建向量库-标题映射表" class="headerlink" title="3. 构建向量库 &amp; 标题映射表"></a>3. 构建向量库 &amp; 标题映射表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python build_vector_store.py</span><br></pre></td></tr></table></figure>

<p>生成文件：</p>
<ul>
<li><code>vector_store.json</code>: 含每篇文章的文本和语义向量</li>
<li><code>title_mapping.json</code>: 含每篇文章的标题 + 主标题 + 链接</li>
</ul>
<p>博客格式需遵循以下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Article Title</span><br><span class="line">date: YYYY-MM-DD HH:mm:ss</span><br><span class="line">tags: [...]  # No impact</span><br><span class="line">categories: ...  # No impact</span><br><span class="line">---</span><br><span class="line"># Main Title  # Must be a first level title</span><br><span class="line"></span><br><span class="line">正文内容...</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-启动后端问答服务"><a href="#4-启动后端问答服务" class="headerlink" title="4. 启动后端问答服务"></a>4. 启动后端问答服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure>

<p>本地服务启动后默认监听：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5000/ask</span><br></pre></td></tr></table></figure>
<p>你可以在浏览器中打开 <code>chat.html</code> 进行测试，查看是否可以正确输出回答。</p>
<hr>
<h2 id="5-配置-Hexo-脚本"><a href="#5-配置-Hexo-脚本" class="headerlink" title="5. 配置 Hexo 脚本"></a>5. 配置 <code>Hexo</code> 脚本</h2><p>如果上述操作都正确执行后，将向量构建脚本接入 <code>Hexo</code> 构建流程</p>
<h3 id="1-创建脚本文件-scripts-auto-vector-js："><a href="#1-创建脚本文件-scripts-auto-vector-js：" class="headerlink" title="1.创建脚本文件 scripts/auto_vector.js："></a>1.创建脚本文件 <code>scripts/auto_vector.js</code>：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&quot;before_generate&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;构建博客向量中...&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">exec</span>(<span class="string">&quot;/your_project/.venv/Scripts/python build_vector_store.py&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">cwd</span>: <span class="string">&quot;D:/your_project&quot;</span></span><br><span class="line">    &#125;, <span class="function">(<span class="params">err, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;构建失败:&quot;</span>, stderr);</span><br><span class="line">        <span class="title function_">reject</span>(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;构建成功&quot;</span>);</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个脚本的作用是在运行 <code>hexo g</code> 时，自动重构向量库保证所有博客均被项链化。</p>
<h3 id="2-在页面底部引入-ejs-文件"><a href="#2-在页面底部引入-ejs-文件" class="headerlink" title="2. 在页面底部引入 ejs 文件"></a>2. 在页面底部引入 ejs 文件</h3><p>打开文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes/hexo-theme-Chic/layout/_partial/footer.ejs</span><br></pre></td></tr></table></figure>

<p>在 <code>&lt;/footer&gt;</code> 标签之后添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%- partial(&#x27;chatbot&#x27;) %&gt;</span><br></pre></td></tr></table></figure>

<p>新建文件 <code>chatbot.ejs</code> 在路径 <code>themes\hexo-theme-Chic\layout\_partial\chatbot.ejs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将chatbot.ejs的代码拷贝至此处</span><br><span class="line">完整代码文件可见文章开头的项目地址中</span><br></pre></td></tr></table></figure>

<p>运行以下命令，重新生成并启动本地预览：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="https://github.com/user-attachments/assets/40f5a3c5-74a6-453b-b83b-6152c5b40990" alt="image"></p>
<hr>
<h2 id="6-使用-Ngrok-暴露后端接口（可选）"><a href="#6-使用-Ngrok-暴露后端接口（可选）" class="headerlink" title="6. 使用 Ngrok 暴露后端接口（可选）"></a>6. 使用 Ngrok 暴露后端接口（可选）</h2><p>在本地测试都没问题后，可以使用 Ngrok 暴露本地服务至公网</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ngrok http 5000</span><br></pre></td></tr></table></figure>

<p>将 <code>https://xxx.ngrok-free.app/ask</code> 地址填入前端请求 <code>chatbot.ejs</code> 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;https://xxx.ngrok-free.app/ask&quot;</span>, &#123;...&#125;);</span><br></pre></td></tr></table></figure>

<p>只使用 Ngrok 有网路安全问题，你可以自行设置代理保证你的端口不被暴露在公网中。</p>
<hr>
<h2 id="完整流程总结"><a href="#完整流程总结" class="headerlink" title="完整流程总结"></a>完整流程总结</h2><ol>
<li>写好博客（Markdown 文件），保证格式符合要求</li>
<li><code>build_vector_store.py</code> 提取文本并生成向量</li>
<li><code>main.py</code> 启动问答服务并支持语义检索</li>
<li>前端请求通过 Ngrok 访问服务</li>
<li>模型结合语义内容和标题表生成参考明确的回答</li>
</ol>
<hr>
<p>该项目代码基于 <a href="https://github.com/hexojs/hexo.git">Hexo</a> 和 <a href="https://github.com/Siricee/hexo-theme-Chic.git">hexo-theme-Chic</a> 。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>前端</tag>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大模型</tag>
        <tag>Agent</tag>
        <tag>RAG</tag>
        <tag>flask</tag>
        <tag>后端</tag>
        <tag>Ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title>Uploading Local Images to Vision LLM</title>
    <url>/2025/04/18/Uploading-Local-Images-to-Vision-LLM/</url>
    <content><![CDATA[<h1 id="如何使用视觉大模型上传本地图像并生成回答"><a href="#如何使用视觉大模型上传本地图像并生成回答" class="headerlink" title="如何使用视觉大模型上传本地图像并生成回答"></a>如何使用视觉大模型上传本地图像并生成回答</h1><p>在本篇博客中，我将讲解如何将本地图片上传至视觉大模型，并让模型生成图像的描述，本文以 Qwen 的模型举例。</p>
<h2 id="1-什么是视觉模型？"><a href="#1-什么是视觉模型？" class="headerlink" title="1. 什么是视觉模型？"></a>1. 什么是视觉模型？</h2><p>视觉模型是一个基于大规模视觉-语言模型的工具，能够将图片与自然语言结合。通过调用该模型，你可以将图像发送给它，并让它生成对图像内容的详细描述。例如，它可以描述图像中的物体、场景甚至情感。</p>
<hr>
<h2 id="2-Qwen官方的-API-调用方法"><a href="#2-Qwen官方的-API-调用方法" class="headerlink" title="2. Qwen官方的 API 调用方法"></a>2. Qwen官方的 API 调用方法</h2><p>Qwen 官方提供的视觉大模型调用方式是通过直接提供图像的 URL 来进行图像分析。代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">from openai import OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">    # 若没有配置环境变量，请用百炼API Key将下行替换为：api_key=&quot;sk-xxx&quot;,</span><br><span class="line">    api_key=os.getenv(&quot;DASHSCOPE_API_KEY&quot;),</span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">    model=&quot;qwen-vl-plus&quot;,  # 此处以qwen-vl-plus为例，可按需更换模型名称。</span><br><span class="line">    messages=[&#123;</span><br><span class="line">        &quot;role&quot;: &quot;user&quot;,</span><br><span class="line">        &quot;content&quot;: [</span><br><span class="line">            &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;这是什么&quot;&#125;,</span><br><span class="line">            &#123;&quot;type&quot;: &quot;image_url&quot;, </span><br><span class="line">             &quot;image_url&quot;: &#123;&quot;url&quot;: &quot;https://dashscope.oss-cn-beijing.aliyuncs.com/images/dog_and_girl.jpeg&quot;&#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(completion.model_dump_json())</span><br></pre></td></tr></table></figure>
<p>这个方法需要将图像的 URL（指向图片存储的网络地址）作为消息发送给模型。</p>
<p>但对于本地图片要上传至大模型处理，先转为 URL 显然有些繁琐。</p>
<hr>
<h2 id="3-如何将本地图片上传至大模型"><a href="#3-如何将本地图片上传至大模型" class="headerlink" title="3. 如何将本地图片上传至大模型"></a>3. 如何将本地图片上传至大模型</h2><p>这里我将介绍一个本地图片上传至 Qwen 视觉模型，并让模型根据prompt生成图像的描述的方法。</p>
<p>以下是完整的代码模板：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import base64</span><br><span class="line">from io import BytesIO</span><br><span class="line">from openai import OpenAI</span><br><span class="line"></span><br><span class="line"># 初始化 API 客户端</span><br><span class="line">client = OpenAI(</span><br><span class="line">    api_key=&quot;你的百炼Key&quot;,</span><br><span class="line">    base_url=&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># === 准备图像（PIL）并转为 base64 ===</span><br><span class="line">def pil_image_to_base64(pil_img: Image.Image) -&gt; str:</span><br><span class="line">    buffered = BytesIO()</span><br><span class="line">    pil_img.save(buffered, format=&quot;JPEG&quot;)</span><br><span class="line">    return base64.b64encode(buffered.getvalue()).decode(&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line"># === 构建调用内容并发送 ===</span><br><span class="line">def call_qwen_vl(pil_img: Image.Image, prompt_text: str = &quot;请描述图像内容&quot;) -&gt; str:</span><br><span class="line">    img_b64 = pil_image_to_base64(pil_img)</span><br><span class="line"></span><br><span class="line">    content = [</span><br><span class="line">        &#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: prompt_text&#125;,</span><br><span class="line">        &#123;&quot;type&quot;: &quot;image_url&quot;, &quot;image_url&quot;: &#123;</span><br><span class="line">            &quot;url&quot;: f&quot;data:image/jpeg;base64,&#123;img_b64&#125;&quot;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    response = client.chat.completions.create(</span><br><span class="line">        model=&quot;qwen-vl-plus&quot;,</span><br><span class="line">        messages=[&#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: content&#125;]</span><br><span class="line">    )</span><br><span class="line">    return response.choices[0].message.content.strip()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相比官方的 API 调用方法，这个方法通过将图像转换为 Base64 编码 字符串的方式传输图像，这样就可以将图像嵌入到请求中，直接将本地图片上传至视觉大模型进行理解</p>
<hr>
<h2 id="4-代码解析"><a href="#4-代码解析" class="headerlink" title="4. 代码解析"></a>4. 代码解析</h2><p>接下来，我们来看如何实现这个过程。整个代码的核心分为几个步骤：图像加载、图像转换为 base64 编码、构建 API 请求、获取并处理模型的响应。</p>
<h3 id="4-1-导入必要的库"><a href="#4-1-导入必要的库" class="headerlink" title="4.1 导入必要的库"></a>4.1 导入必要的库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>PIL</strong>：用于打开和处理图像文件。</li>
<li><strong>base64</strong>：用于将图像数据转换为 base64 编码，使其适合通过 HTTP 请求传输。</li>
<li><strong>BytesIO</strong>：将图像数据保存在内存中的缓冲区，而不是写入磁盘。</li>
<li><strong>OpenAI</strong>：用于与 OpenAI API 进行交互，调用 Qwen-VL 模型。</li>
</ul>
<h3 id="4-2-初始化-API-客户端"><a href="#4-2-初始化-API-客户端" class="headerlink" title="4.2 初始化 API 客户端"></a>4.2 初始化 API 客户端</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">client = OpenAI(</span><br><span class="line">    api_key=<span class="string">&quot;你的百炼Key&quot;</span>,</span><br><span class="line">    base_url=<span class="string">&quot;https://dashscope.aliyuncs.com/compatible-mode/v1&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你需要提供一个 <strong>API 密钥</strong>（<code>api_key</code>）来进行身份验证。<code>base_url</code> 是 API 的地址，用来与 Qwen 模型通信。</p>
<h3 id="4-3-图像转换为-Base64-编码"><a href="#4-3-图像转换为-Base64-编码" class="headerlink" title="4.3 图像转换为 Base64 编码"></a>4.3 图像转换为 Base64 编码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pil_image_to_base64</span>(<span class="params">pil_img: Image.Image</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    buffered = BytesIO()</span><br><span class="line">    pil_img.save(buffered, <span class="built_in">format</span>=<span class="string">&quot;JPEG&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(buffered.getvalue()).decode(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码的作用是将图像从 <strong>PIL 图像格式</strong> 转换为 <strong>base64 编码</strong>，并返回一个字符串。为什么要这么做呢？</p>
<ul>
<li>图像是二进制数据，而网络通信（特别是通过 HTTP 请求）更擅长处理文本数据。通过将图像转换为 base64 编码，我们可以轻松地将其嵌入到文本请求中发送给 API。</li>
<li><code>BytesIO()</code> 是一个内存中的文件对象，用来暂存图像数据。</li>
<li><code>pil_img.save(buffered, format=&quot;JPEG&quot;)</code> 将图像保存到内存中的缓冲区（<code>buffered</code>），并指定图像格式为 JPEG。</li>
<li><code>base64.b64encode(buffered.getvalue())</code> 将内存中的图像数据进行 base64 编码。</li>
<li><code>.decode(&quot;utf-8&quot;)</code> 将编码后的字节数据转换为可读的字符串。</li>
</ul>
<h3 id="4-4-构建-API-请求并发送"><a href="#4-4-构建-API-请求并发送" class="headerlink" title="4.4 构建 API 请求并发送"></a>4.4 构建 API 请求并发送</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">call_qwen_vl</span>(<span class="params">pil_img: Image.Image, prompt_text: <span class="built_in">str</span> = <span class="string">&quot;请描述图像内容&quot;</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    img_b64 = pil_image_to_base64(pil_img)</span><br><span class="line"></span><br><span class="line">    content = [</span><br><span class="line">        &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>, <span class="string">&quot;text&quot;</span>: prompt_text&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;image_url&quot;</span>, <span class="string">&quot;image_url&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;url&quot;</span>: <span class="string">f&quot;data:image/jpeg;base64,<span class="subst">&#123;img_b64&#125;</span>&quot;</span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    response = client.chat.completions.create(</span><br><span class="line">        model=<span class="string">&quot;qwen-vl-plus&quot;</span>,</span><br><span class="line">        messages=[&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: content&#125;]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> response.choices[<span class="number">0</span>].message.content.strip()</span><br></pre></td></tr></table></figure>

<p>这一段是代码的核心，主要完成了以下工作：</p>
<ol>
<li><p><strong>将图像转换为 Base64</strong>：我们先调用前面写的 <code>pil_image_to_base64()</code> 函数将图像转换为 base64 编码。</p>
</li>
<li><p><strong>构建请求内容</strong>：这里我们准备了一个内容列表 <code>content</code>，包括了两个部分：</p>
<ul>
<li><strong>文本提示</strong>：<code>&#123;&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: prompt_text&#125;</code>，这是给模型的提示，告诉它需要描述图像的内容。默认的prompt文本是“请描述图像内容”。</li>
<li><strong>图像数据</strong>：<code>&#123;&quot;type&quot;: &quot;image_url&quot;, &quot;image_url&quot;: &#123;&quot;url&quot;: f&quot;data:image/jpeg;base64,&#123;img_b64&#125;&quot;&#125;&#125;</code>。这里我们使用了一个 <code>data:image/jpeg;base64,...</code> 的 URL 格式来将图像数据嵌入请求中，这个过程避免了图像必须托管在网络上的限制。</li>
</ul>
</li>
<li><p><strong>发送请求</strong>：<code>client.chat.completions.create(...)</code> 这行代码通过 OpenAI 客户端向 Qwen-VL 模型发送请求。这里指定了使用的模型 <code>qwen-vl-plus</code>（你可以自己跟换所需的视觉大模型），并将构建好的消息内容传递给模型。</p>
</li>
<li><p><strong>获取响应</strong>：模型处理完图像后，会返回一个响应。我们从 <code>response.choices[0].message.content</code> 中提取出模型生成的描述，并使用 <code>.strip()</code> 去除两端的空白字符。</p>
</li>
</ol>
<h3 id="4-5-完整流程"><a href="#4-5-完整流程" class="headerlink" title="4.5 完整流程"></a>4.5 完整流程</h3><ol>
<li><strong>加载图像</strong>：首先从本地加载图像，通常使用 <code>PIL.Image.open()</code> 来打开文件。</li>
<li><strong>图像转换</strong>：然后我们将图像转换为 base64 编码，使其能够通过网络请求安全传输。</li>
<li><strong>构建请求并发送给 Qwen-VL 模型</strong>：构建一个包含图像和文本提示的请求，发送给 Qwen-VL 模型。</li>
<li><strong>接收并处理模型的响应</strong>：模型会分析图像并生成一段描述文本，我们从响应中提取并返回这段文本。</li>
</ol>
<h2 id="5-示例：如何使用该代码"><a href="#5-示例：如何使用该代码" class="headerlink" title="5. 示例：如何使用该代码"></a>5. 示例：如何使用该代码</h2><p>假设你有一个本地的图像文件 <code>example.jpg</code>，你想让视觉模型描述它的内容。以下是一个简单的代码示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开本地图像文件</span></span><br><span class="line">image_path = <span class="string">&quot;example.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(image_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 Qwen-VL 模型获取图像描述</span></span><br><span class="line">description = call_qwen_vl(img)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;图像描述：&quot;</span>, description)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-结果"><a href="#5-1-结果" class="headerlink" title="5.1 结果"></a>5.1 结果</h3><p>当你运行这段代码时，模型会分析图像并生成对该图像的描述。例如，它可能会返回类似这样的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图像描述：这是一张包含一个绿色苹果的照片，苹果放置在白色背景上，旁边还有一些小草。</span><br></pre></td></tr></table></figure>

<hr>
<p>该项目代码参考 <a href="https://bailian.console.aliyun.com/?spm=5176.28197619.aillm.2.4d7a1ad8wlSXpQ&scm=20140722.S_%E5%AF%BC%E8%88%AA%E5%88%B0%E6%A8%A1%E5%9E%8B%E5%B9%BF%E5%9C%BA._.RL_%E5%AF%BC%E8%88%AA%E5%88%B0%E6%A8%A1%E5%9E%8B%E5%B9%BF%E5%9C%BA-LOC_aillm-OR_chat-V_3-RC_llm&accounttraceid=2fcac53a3ff94398a308227a35f9638fekhp&tab=api#/api/?type=model&url=https%3A%2F%2Fhelp.aliyun.com%2Fdocument_detail%2F2712576.html%23cde3eb109flda">Qwen官方的视觉模型图像输入使用方法</a>。</p>
]]></content>
      <categories>
        <category>LLM学习之路</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>LLM</tag>
        <tag>大模型</tag>
        <tag>Qwen</tag>
        <tag>Agent</tag>
        <tag>Python</tag>
        <tag>视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>「LeetCode」 Palindrome Number</title>
    <url>/2025/04/10/%E3%80%8CLeetCode%E3%80%8D-Palindrome-Number/</url>
    <content><![CDATA[<h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>回文数</strong> 是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<strong>121</strong> 是回文，而 <strong>123</strong> 不是。</li>
</ul>
<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：121 → 输出：true</span><br><span class="line">输入：-121 → 输出：false</span><br><span class="line">输入：10 → 输出：false</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="方法-1：字符串切片"><a href="#方法-1：字符串切片" class="headerlink" title="方法 1：字符串切片"></a>方法 1：字符串切片</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><p>要判断一个整数是否是回文数，可以通过以下步骤实现：</p>
<ul>
<li>负数处理 ：如果输入的整数 x 是负数，则它不可能是回文数，因为负号会让正序和倒序不同。</li>
<li>反转数字比较 ：将整数反转后与原整数进行比较。如果两者相等，则说明它是回文数。</li>
</ul>
<hr>
<h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def isPalindrome(self, x):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 如果 x 是负数，直接返回 False</span><br><span class="line">        if x &lt; 0:</span><br><span class="line">            return False</span><br><span class="line">        </span><br><span class="line">        # 将整数转换为字符串</span><br><span class="line">        str_x = str(x)</span><br><span class="line">        </span><br><span class="line">        # 判断字符串是否等于其反转后的结果</span><br><span class="line">        return str_x == str_x[::-1]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="逐行代码解析"><a href="#逐行代码解析" class="headerlink" title="逐行代码解析"></a>逐行代码解析</h3><h4 id="1-负数处理"><a href="#1-负数处理" class="headerlink" title="1. 负数处理"></a>1. 负数处理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if x &lt; 0:</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure>

<p>如果输入的整数 <code>x</code> 是负数，直接返回 <code>False</code>。</p>
<hr>
<h4 id="2-整数转字符串"><a href="#2-整数转字符串" class="headerlink" title="2. 整数转字符串"></a>2. 整数转字符串</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str_x = str(x)</span><br></pre></td></tr></table></figure>

<p>为什么要转换为字符串？</p>
<ul>
<li>字符串支持切片操作（如 <code>[::-1]</code>），可以方便地获取字符串的反转结果。</li>
<li>直接操作整数无法实现类似的反转操作。</li>
</ul>
<hr>
<h4 id="3-判断回文数"><a href="#3-判断回文数" class="headerlink" title="3. 判断回文数"></a>3. 判断回文数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return str_x == str_x[::-1]</span><br></pre></td></tr></table></figure>

<p>判断字符串 <code>str_x</code> 是否等于它的反转字符串 <code>str_x[::-1]</code>。</p>
<p>如果相等，则返回 <code>True</code>，表示 <code>x</code> 是回文数；否则返回 <code>False</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str_x[::-1]是 Python 的切片操作，用于反转字符串。</span><br><span class="line"></span><br><span class="line">切片语法 [start:end:step]：</span><br><span class="line">start：起始索引（默认为第一个字符）。</span><br><span class="line">end：结束索引（默认为最后一个字符之后）。</span><br><span class="line">step：步长（正值表示正向取值，负值表示反向取值）。</span><br><span class="line">[::-1] 表示从字符串的末尾开始，以步长 -1 反向取值，从而实现字符串的反转。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="方法-2：不使用字符串（仅用数学运算）"><a href="#方法-2：不使用字符串（仅用数学运算）" class="headerlink" title="方法 2：不使用字符串（仅用数学运算）"></a>方法 2：不使用字符串（仅用数学运算）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>我们不能用 <code>str(x)</code> 把整数转成字符串。因此，需要用数学方式构造 “整数的倒序表示”，并且仅构造一半就能进行对比：</p>
<ul>
<li>如果数是回文，则前半部分和后半部分是一样的，我们可以转计后半部数字，和剩下的 x 进行比较即可。</li>
</ul>
<hr>
<h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>如果 x &lt; 0，是负数，不可能是回文</li>
<li>如果 x 最后一位是 0，但 x 不是 0，也不是回文</li>
<li>通过每次抽出 x 的最后一位，加到 reversed_half 的尾部，并把 x 去掉最后一位</li>
<li>当 reversed_half 大于或等于 x 时，表示已处理到中间，开始比较</li>
</ol>
<hr>
<h3 id="示意图：1221-如何处理"><a href="#示意图：1221-如何处理" class="headerlink" title="示意图：1221 如何处理"></a>示意图：1221 如何处理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1221</span><br><span class="line">reversed_half = 0</span><br><span class="line"></span><br><span class="line">步骤：</span><br><span class="line">取 1： reversed_half = 1， x = 122</span><br><span class="line">取 2： reversed_half = 12， x = 12</span><br><span class="line"></span><br><span class="line">比较: x == reversed_half → 是，返回 true</span><br></pre></td></tr></table></figure>

<h3 id="如果不是回文：示例-x-1234"><a href="#如果不是回文：示例-x-1234" class="headerlink" title="如果不是回文：示例 x &#x3D; 1234"></a>如果不是回文：示例 x &#x3D; 1234</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1234</span><br><span class="line">reversed_half = 0</span><br><span class="line"></span><br><span class="line">取 4 → reversed_half = 4， x = 123</span><br><span class="line">取 3 → reversed_half = 43， x = 12</span><br><span class="line"></span><br><span class="line">比较: x = 12, reversed_half = 43 → 不等</span><br><span class="line">返回 false</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        reversed_half = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; reversed_half:</span><br><span class="line">            reversed_half = reversed_half * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x == reversed_half <span class="keyword">or</span> x == reversed_half // <span class="number">10</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="逐行代码解析-1"><a href="#逐行代码解析-1" class="headerlink" title="逐行代码解析"></a>逐行代码解析</h3><h4 id="1-提前处理-明显不是回文数-的情况"><a href="#1-提前处理-明显不是回文数-的情况" class="headerlink" title="1. 提前处理 明显不是回文数 的情况"></a>1. 提前处理 明显不是回文数 的情况</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> (x % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> x != <span class="number">0</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>负数和以 0 结尾的非 0 整数不能是回文</li>
</ul>
<hr>
<h4 id="2-创建一个变量用来保存-从后往前取出来的一半数字（反转的一半）"><a href="#2-创建一个变量用来保存-从后往前取出来的一半数字（反转的一半）" class="headerlink" title="2. 创建一个变量用来保存 从后往前取出来的一半数字（反转的一半）"></a>2. 创建一个变量用来保存 从后往前取出来的一半数字（反转的一半）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reversed_half = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-控制什么时候“反转了一半”"><a href="#3-控制什么时候“反转了一半”" class="headerlink" title="3. 控制什么时候“反转了一半”"></a>3. 控制什么时候“反转了一半”</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while x &gt; reversed_half:</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1221</span><br><span class="line">reversed_half = 0</span><br><span class="line"></span><br><span class="line"># 第一次：拿出 1 → reversed_half = 1，x = 122</span><br><span class="line"># 第二次：拿出 2 → reversed_half = 12，x = 12</span><br><span class="line"></span><br><span class="line">此时：</span><br><span class="line">x == reversed_half → 循环结束</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-反转核心逻辑"><a href="#4-反转核心逻辑" class="headerlink" title="4. 反转核心逻辑"></a>4. 反转核心逻辑</h4><p>我们要把整数 x 的最后一位一位“提取出来”，然后像搭积木一样把这些数字反转组合起来。 </p>
<p>比如，我们有一个数 x &#x3D; 1234，我们想把它从后往前反转得到：4321</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reversed_half = reversed_half * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">x //= <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p><strong>举例</strong>：</p>
<p>初始状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = 1234</span><br><span class="line">reversed_half = 0</span><br></pre></td></tr></table></figure>

<p>第一步循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reversed_half = 0 * 10 + 1234 % 10 = 0 + 4 = 4</span><br><span class="line">x = 1234 // 10 = 123</span><br></pre></td></tr></table></figure>
<p>第二步循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reversed_half = 4 * 10 + 123 % 10 = 40 + 3 = 43</span><br><span class="line">x = 123 // 10 = 12</span><br></pre></td></tr></table></figure>
<p>第三步循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reversed_half = 43 * 10 + 12 % 10 = 430 + 2 = 432</span><br><span class="line">x = 12 // 10 = 1</span><br></pre></td></tr></table></figure>
<p>第四步循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reversed_half = 432 * 10 + 1 % 10 = 4320 + 1 = 4321</span><br><span class="line">x = 1 // 10 = 0</span><br></pre></td></tr></table></figure>

<p><code>x % 10</code>: 作用是取出数字的最后一位，例如 <code>123 % 10 = 3</code></p>
<p><code>x //= 10</code>: 整除 10，相当于<code>x = x // 10</code></p>
<ul>
<li>作用是把数字“去掉最后一位,例如 <code>123 // 10 = 12</code></li>
</ul>
<p><code>reversed_half * 10</code>: 作用是把上一轮的最后一位往前推进一格</p>
<h4 id="5-判断是不是回文"><a href="#5-判断是不是回文" class="headerlink" title="5. 判断是不是回文"></a>5. 判断是不是回文</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> x == reversed_half <span class="keyword">or</span> x == reversed_half // <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>如果是偶数位数字，例如 1221：</p>
<ul>
<li>比较 <code>x == reversed_half</code>，就是 12 &#x3D;&#x3D; 12</li>
</ul>
<p>如果是奇数位数字，例如 12321：</p>
<ul>
<li>反转时 <code>reversed_half</code> 会多出一个中间数（比如 123）</li>
<li>需要去掉中间数再比较：<code>reversed_half // 10</code> 就是去掉最后一位（3 → 去掉 3）</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>代码学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>「LeetCode」 Two Sum</title>
    <url>/2025/04/09/%E3%80%8CLeetCode%E3%80%8D-Two-Sum/</url>
    <content><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>开始学习Python的第一天，努力ing</p>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那两个整数，并返回它们的数组下标。</p>
<ul>
<li><strong>输入</strong>：<ul>
<li>数组 <code>nums</code>（长度至少为 2）。</li>
<li>目标值 <code>target</code>。</li>
</ul>
</li>
<li><strong>输出</strong>：<ul>
<li>返回两个数的索引，使得它们的和等于目标值。</li>
</ul>
</li>
<li><strong>假设</strong>：<ul>
<li>每种输入只会对应一个答案。</li>
<li>你不能使用同一个元素两次。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2, 7, 11, 15], target = 9</span><br><span class="line">输出：[0, 1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]。</span><br></pre></td></tr></table></figure>

<h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3, 2, 4], target = 6</span><br><span class="line">输出：[1, 2]</span><br></pre></td></tr></table></figure>

<h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3, 3], target = 6</span><br><span class="line">输出：[0, 1]</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="方法-1：暴力法"><a href="#方法-1：暴力法" class="headerlink" title="方法 1：暴力法"></a>方法 1：暴力法</h2><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>使用外层循环固定第一个数的索引 <code>i</code>。</li>
<li>使用内层循环从 <code>i+1</code> 开始，检查后续的所有数。</li>
<li>如果两个数的和等于目标值 <code>target</code>，立即返回它们的索引。</li>
<li>如果遍历结束仍未找到符合条件的两个数，则返回空列表。</li>
</ol>
<h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 外层循环固定第一个数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 内层循环从 i+1 开始，避免重复使用元素</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="comment"># 检查两数之和是否等于目标值</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="comment"># 如果找到，立即返回索引</span></span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        <span class="comment"># 根据题目假设，这里不会执行到</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>


<h3 id="示例运行"><a href="#示例运行" class="headerlink" title="示例运行"></a>示例运行</h3><h4 id="输入：nums-2-7-11-15-target-9"><a href="#输入：nums-2-7-11-15-target-9" class="headerlink" title="输入：nums = [2, 7, 11, 15], target = 9"></a>输入：<code>nums = [2, 7, 11, 15], target = 9</code></h4><ul>
<li>外层循环 <code>i = 0</code>，内层循环：<ul>
<li><code>j = 1</code>，<code>nums[0] + nums[1] = 2 + 7 = 9</code>，找到答案，返回 <code>[0, 1]</code>。</li>
</ul>
</li>
</ul>
<h4 id="输入：nums-3-2-4-target-6"><a href="#输入：nums-3-2-4-target-6" class="headerlink" title="输入：nums = [3, 2, 4], target = 6"></a>输入：<code>nums = [3, 2, 4], target = 6</code></h4><ul>
<li>外层循环 <code>i = 0</code>，内层循环：<ul>
<li><code>j = 1</code>，<code>nums[0] + nums[1] = 3 + 2 = 5</code>，不匹配。</li>
<li><code>j = 2</code>，<code>nums[0] + nums[2] = 3 + 4 = 7</code>，不匹配。</li>
</ul>
</li>
<li>外层循环 <code>i = 1</code>，内层循环：<ul>
<li><code>j = 2</code>，<code>nums[1] + nums[2] = 2 + 4 = 6</code>，找到答案，返回 <code>[1, 2]</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="逐行代码解析"><a href="#逐行代码解析" class="headerlink" title="逐行代码解析"></a>逐行代码解析</h3><h4 id="1-定义类和方法"><a href="#1-定义类和方法" class="headerlink" title="1. 定义类和方法"></a>1. 定义类和方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>class Solution(object)</code></strong>：定义一个类 <code>Solution</code>，用于组织代码。</li>
<li><strong><code>def twoSum(self, nums, target)</code></strong>：定义一个方法 <code>twoSum</code>，接收两个参数：<ul>
<li><code>nums</code>：一个列表（数组），例如 <code>[2, 7, 11, 15]</code>。</li>
<li><code>target</code>：目标值，例如 <code>9</code>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-外层循环"><a href="#2-外层循环" class="headerlink" title="2. 外层循环"></a>2. 外层循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>range(len(nums))</code></strong>：生成从 <code>0</code> 到 <code>len(nums)-1</code> 的数字序列。</li>
<li><strong><code>i</code></strong>：外层循环变量，表示当前固定的第一个数的索引。</li>
</ul>
<p>这里 <code>len(nums)</code>的值为4,所以 <code>range(len(nums))</code> 就是0，1，2，3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">range(start, stop, step) 是一个内置函数，用于生成一系列整数。它的参数有三个：</span><br><span class="line"></span><br><span class="line">start （可选）：序列的起始值，默认为 0。</span><br><span class="line"></span><br><span class="line">stop ：序列的结束值（不包括这个值）。</span><br><span class="line"></span><br><span class="line">step （可选）：步长，默认为 1。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">for i in range(5):  # 等价于 range(0, 5)</span><br><span class="line">    print(i)</span><br><span class="line">输出：0 1 2 3 4</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-内层循环"><a href="#3-内层循环" class="headerlink" title="3. 内层循环"></a>3. 内层循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>range(i + 1, len(nums))</code></strong>：生成从 <code>i+1</code> 到 <code>len(nums)-1</code> 的数字序列。</li>
<li><strong><code>j</code></strong>：内层循环变量，表示第二个数的索引。</li>
<li><strong>注意</strong>：从 <code>i+1</code> 开始，确保不会重复使用同一个元素。</li>
</ul>
<hr>
<h4 id="4-检查条件"><a href="#4-检查条件" class="headerlink" title="4. 检查条件"></a>4. 检查条件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> nums[i] + nums[j] == target:</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>nums[i]</code> 和 <code>nums[j]</code></strong>：分别表示数组中索引为 <code>i</code> 和 <code>j</code> 的元素。</li>
<li><strong><code>nums[i] + nums[j] == target</code></strong>：检查这两个数的和是否等于目标值。</li>
</ul>
<hr>
<h4 id="5-返回结果"><a href="#5-返回结果" class="headerlink" title="5. 返回结果"></a>5. 返回结果</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [i, j]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>[i, j]</code></strong>：如果找到符合条件的两个数，返回它们的索引。</li>
<li><strong><code>return</code></strong>：结束函数并返回结果。</li>
</ul>
<hr>
<h4 id="6-默认返回空列表"><a href="#6-默认返回空列表" class="headerlink" title="6. 默认返回空列表"></a>6. 默认返回空列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有找到符合条件的两个数，返回一个空列表 <code>[]</code>。</li>
<li>根据题目假设，这种情况不会发生。</li>
</ul>
<hr>
<h2 id="方法-2：哈希表方法"><a href="#方法-2：哈希表方法" class="headerlink" title="方法 2：哈希表方法"></a>方法 2：哈希表方法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>哈希表方法是一种更高效的解决方案。它的核心思想是利用一个字典（哈希表）来存储已经访问过的数字及其索引。在遍历数组的过程中，对于当前数字 <code>num</code>，计算它的补数 <code>complement = target - num</code>，然后检查补数是否已经在哈希表中。如果存在，则找到了两个数；否则，将当前数字存入哈希表。</p>
<h3 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li>创建一个空字典 <code>num_to_index</code>，用于存储已访问的数字及其索引。</li>
<li>遍历数组，对于每个数字 <code>num</code>：<ul>
<li>计算补数 <code>complement = target - num</code>。</li>
<li>检查补数是否已经在字典中：<ul>
<li>如果存在，则返回补数的索引和当前数字的索引。</li>
<li>如果不存在，则将当前数字及其索引存入字典。</li>
</ul>
</li>
</ul>
</li>
<li>根据题目假设，一定会找到答案，因此不需要处理找不到的情况。</li>
</ol>
<h3 id="Python-实现-1"><a href="#Python-实现-1" class="headerlink" title="Python 实现"></a>Python 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        <span class="comment"># 创建一个哈希表用于存储已访问的元素及其索引</span></span><br><span class="line">        num_to_index = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># 计算需要的另一个数</span></span><br><span class="line">            complement = target - num</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 检查这个数是否已经在哈希表中</span></span><br><span class="line">            <span class="keyword">if</span> complement <span class="keyword">in</span> num_to_index:</span><br><span class="line">                <span class="comment"># 如果找到，返回结果</span></span><br><span class="line">                <span class="keyword">return</span> [num_to_index[complement], i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 否则，将当前数和其索引存入哈希表</span></span><br><span class="line">            num_to_index[num] = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> []  <span class="comment"># 根据题目假设，这里不会执行到</span></span><br></pre></td></tr></table></figure>

<h3 id="示例运行-1"><a href="#示例运行-1" class="headerlink" title="示例运行"></a>示例运行</h3><h4 id="输入：nums-2-7-11-15-target-9-1"><a href="#输入：nums-2-7-11-15-target-9-1" class="headerlink" title="输入：nums = [2, 7, 11, 15], target = 9"></a>输入：<code>nums = [2, 7, 11, 15], target = 9</code></h4><ul>
<li>第一步：<code>num = 2, complement = 9 - 2 = 7</code>，哈希表为空，存入 <code>&#123;2: 0&#125;</code>。</li>
<li>第二步：<code>num = 7, complement = 9 - 7 = 2</code>，发现 <code>2</code> 在哈希表中，返回 <code>[0, 1]</code>。</li>
</ul>
<h4 id="输入：nums-3-2-4-target-6-1"><a href="#输入：nums-3-2-4-target-6-1" class="headerlink" title="输入：nums = [3, 2, 4], target = 6"></a>输入：<code>nums = [3, 2, 4], target = 6</code></h4><ul>
<li>第一步：<code>num = 3, complement = 6 - 3 = 3</code>，哈希表为空，存入 <code>&#123;3: 0&#125;</code>。</li>
<li>第二步：<code>num = 2, complement = 6 - 2 = 4</code>，哈希表为 <code>&#123;3: 0&#125;</code>，存入 <code>&#123;3: 0, 2: 1&#125;</code>。</li>
<li>第三步：<code>num = 4, complement = 6 - 4 = 2</code>，发现 <code>2</code> 在哈希表中，返回 <code>[1, 2]</code>。</li>
</ul>
<hr>
<h3 id="逐行代码解析-1"><a href="#逐行代码解析-1" class="headerlink" title="逐行代码解析"></a>逐行代码解析</h3><h4 id="1-创建哈希表"><a href="#1-创建哈希表" class="headerlink" title="1. 创建哈希表"></a>1. 创建哈希表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_to_index = &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>num_to_index</code></strong>：这是一个空字典（哈希表），用于存储已经访问过的数字及其索引。</li>
<li>键是数字，值是它的索引。</li>
</ul>
<hr>
<h4 id="2-遍历数组"><a href="#2-遍历数组" class="headerlink" title="2. 遍历数组"></a>2. 遍历数组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>enumerate(nums)</code></strong>：同时获取数组的索引和对应的值。</li>
<li><strong><code>i</code></strong>：当前数字的索引。</li>
<li><strong><code>num</code></strong>：当前数字的值。</li>
</ul>
<p><code>enumerate()</code> 主要用于在遍历可迭代对象（如列表、元组、字符串等）时，同时获取元素的索引和值。它返回一个枚举对象，其中每个元素是一个包含索引和对应值的元组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enumerate(iterable, start=0)</span><br><span class="line">iterable : 要遍历的可迭代对象（如列表、元组、字符串等）。</span><br><span class="line">start （可选）: 枚举的起始索引，默认为 0。可以通过设置 start 参数来指定从哪个索引开始计数。</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">fruits = [&#x27;apple&#x27;, &#x27;banana&#x27;, &#x27;cherry&#x27;]</span><br><span class="line"></span><br><span class="line">for index, fruit in enumerate(fruits):</span><br><span class="line">    print(f&quot;Index: &#123;index&#125;, Fruit: &#123;fruit&#125;&quot;)</span><br><span class="line">    </span><br><span class="line">输出：</span><br><span class="line">Index: 0, Fruit: apple</span><br><span class="line">Index: 1, Fruit: banana</span><br><span class="line">Index: 2, Fruit: cherry</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-计算补数"><a href="#3-计算补数" class="headerlink" title="3. 计算补数"></a>3. 计算补数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">complement = target - num</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>complement</code></strong>：这是我们需要找的“补数”，即 <code>target - num</code>。</li>
<li>如果当前数字 <code>num</code> 和某个数字的和等于 <code>target</code>，那么那个数字就是 <code>complement</code>。</li>
</ul>
<hr>
<h4 id="4-检查补数是否在哈希表中"><a href="#4-检查补数是否在哈希表中" class="headerlink" title="4. 检查补数是否在哈希表中"></a>4. 检查补数是否在哈希表中</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> complement <span class="keyword">in</span> num_to_index:</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>complement in num_to_index</code></strong>：检查字典中是否存在键 <code>complement</code>。</li>
<li>如果存在，说明我们找到了符合条件的两个数。</li>
</ul>
<hr>
<h4 id="5-返回结果-1"><a href="#5-返回结果-1" class="headerlink" title="5. 返回结果"></a>5. 返回结果</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> [num_to_index[complement], i]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>num_to_index[complement]</code></strong>：从字典中取出 <code>complement</code> 对应的索引。</li>
<li><strong><code>i</code></strong>：当前数字的索引。</li>
<li>返回的是一个包含两个索引的列表。</li>
</ul>
<hr>
<h4 id="6-更新哈希表"><a href="#6-更新哈希表" class="headerlink" title="6. 更新哈希表"></a>6. 更新哈希表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num_to_index[num] = i</span><br></pre></td></tr></table></figure>
<ul>
<li>如果补数不存在，则将当前数字及其索引存入字典。</li>
<li><strong><code>num_to_index[num] = i</code></strong>：将当前数字作为键，索引作为值存入字典。</li>
</ul>
<hr>
<h4 id="7-默认返回空列表"><a href="#7-默认返回空列表" class="headerlink" title="7. 默认返回空列表"></a>7. 默认返回空列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>
<ul>
<li>如果没有找到符合条件的两个数，返回一个空列表 <code>[]</code>。</li>
<li>根据题目假设，这种情况不会发生。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>代码学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>About Me</title>
    <url>/about/index.html</url>
    <content><![CDATA[<h2 id="👋-你好，我是-Evan-Zhong！"><a href="#👋-你好，我是-Evan-Zhong！" class="headerlink" title="👋 你好，我是 Evan Zhong！"></a>👋 你好，我是 Evan Zhong！</h2><ul>
<li>目前是东南大学研究生在读</li>
<li>研究方向是多模态大模型 &#x2F; Graph RAG &#x2F; LLM的Agent构建</li>
</ul>
<h2 id="🔧-科研与项目经历"><a href="#🔧-科研与项目经历" class="headerlink" title="🔧 科研与项目经历"></a>🔧 科研与项目经历</h2><h3 id="面向电子器件datasheet的多模态知识图谱构建与社区化图检索增强查询"><a href="#面向电子器件datasheet的多模态知识图谱构建与社区化图检索增强查询" class="headerlink" title="面向电子器件datasheet的多模态知识图谱构建与社区化图检索增强查询"></a>面向电子器件datasheet的<strong>多模态知识图谱</strong>构建与<strong>社区化图检索增强查询</strong></h3><ul>
<li><strong>基于Docling的多模态文档解构与语义修复</strong>：利用<strong>多模态VLM</strong>对图片进行上下文感知的信息抽取，生成准确的图片信息与关联实体抽取。</li>
<li><strong>采用同源双视角的语义分块策略</strong>，将 Markdown 文档智能地拆分为最小的、有意义的“结构块”，根据文档中最大的“结构块”来动态计算一个合适的分块尺寸，保持 chunk 语义结构完整且长度合理。同时构建<strong>分块视角1</strong>：纯文本去图分块，减噪音，有利于模型聚焦，精确抽取出型号实体；<strong>分块视角2</strong>：保留图片，为每个chunk创建一个包含其前后相邻chunk内容的滑动。这些chunk拥有更完整的语义，用于抽取器件参数。</li>
<li><strong>通过LLM驱动的Agent实体决策与融合实现电子器件的知识图谱构建</strong>：利用LLM驱动的型号名称消歧与融合实现器件的准确提取，基于双视角的数据融合与器件参数抽取，利用LLM驱动的冲突参数智能决策机制，实现准确构建规范化的多模态电子器件知识图谱。</li>
<li><strong>采用社区化构建的图谱检索增强生成</strong>：引入“社区”划分的器件图谱检索，类似于 GraphRAG 的社区层次索引思想。针对电子领域知识各子领域的特点构建不同的社区；通过Query改写理解用户意图并用领域术语表达重写&#x2F;扩写提问；提供LLM规划图谱检索的路径：确定从哪个社区&#x2F;实体出发、沿哪些关系遍历，实现多跳路径推理；采用<strong>混合自适应剪枝（Beam Search + 语义剪枝）</strong>，获取更为精准的检索路径，避免多跳推理时的路径的组合爆炸。</li>
</ul>
<h3 id="基于-Django-MySQL-构建的电弧故障数据管理与分析平台（全栈开发）"><a href="#基于-Django-MySQL-构建的电弧故障数据管理与分析平台（全栈开发）" class="headerlink" title="基于 Django + MySQL 构建的电弧故障数据管理与分析平台（全栈开发）"></a>基于 <strong>Django</strong> + <strong>MySQL</strong> 构建的电弧故障数据管理与分析平台（全栈开发）</h3><ul>
<li>前端使用 <strong>HTML5</strong> &#x2F; <strong>CSS3</strong> &#x2F; <strong>JavaScript</strong> + <strong>Fetch API</strong> 实现交互式页面与 <strong>RESTful API</strong> 通信。</li>
<li>后端基于 <strong>Django</strong> 构建自定义用户系统，使用 <strong>ORM</strong> 管理用户、电弧数据、算法模型与测试结果，实现用户认证、数据上传、特征提取、算法模型评估与可视化等功能。</li>
<li>设计 <strong>FFT</strong> 实现电弧故障信号的特征工程，包括时域分析、频域分析和小波分析。</li>
<li>设计实现完善的用户管理系统，包括用户认证、个人资料管理等功能。</li>
<li>支持企业与用户自行上传算法模型评估（准确率、F1 分数、混淆矩阵等、误判率）。</li>
</ul>
<h3 id="补苗移栽机器人（2020-10-2020-12）"><a href="#补苗移栽机器人（2020-10-2020-12）" class="headerlink" title="补苗移栽机器人（2020&#x2F;10 - 2020&#x2F;12）"></a>补苗移栽机器人（2020&#x2F;10 - 2020&#x2F;12）</h3><ul>
<li>设计机械臂结构</li>
<li>主控 STM32 + 电机驱动电路设计</li>
<li>行走程序编写（基于超声波传感器）</li>
</ul>
<h3 id="三相-AC-DC-变换电路（2021-11）"><a href="#三相-AC-DC-变换电路（2021-11）" class="headerlink" title="三相 AC-DC 变换电路（2021&#x2F;11）"></a>三相 AC-DC 变换电路（2021&#x2F;11）</h3><ul>
<li>三相 PWM 整流双闭环电路设计</li>
<li>MATLAB 仿真建模与验证</li>
<li>实物电路焊接调试</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>category</title>
    <url>/category/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/code-copy.js</url>
    <content><![CDATA[document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('figure.highlight').forEach((figure) => {
    if (figure.querySelector('.copy-btn')) return;

    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.title = '复制';

    // 缩小后的复制图标（14*15）
    const copyIcon = `
      <svg xmlns="http://www.w3.org/2000/svg" height="14" width="15" viewBox="0 0 24 24" fill="white">
        <path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 18H8V7h11v16z"/>
      </svg>
    `;

    // 成功后显示的勾（14*15）
    const checkIcon = `
      <svg xmlns="http://www.w3.org/2000/svg" height="14" width="15" viewBox="0 0 24 24" fill="#00cc66">
        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
      </svg>
    `;

    copyBtn.innerHTML = copyIcon;

    // 按钮样式（浅灰底、缩小）
    Object.assign(copyBtn.style, {
      position: 'absolute',
      top: '8px',
      right: '8px',
      padding: '4px',
      background: '#aaa', // 浅灰背景 ✅
      border: 'none',
      borderRadius: '4px',
      cursor: 'pointer',
      opacity: '0.85',
      zIndex: 1000,
      transition: 'opacity 0.2s ease',
      boxShadow: '0 1px 3px rgba(0, 0, 0, 0.15)'
    });

    copyBtn.addEventListener('mouseover', () => copyBtn.style.opacity = '1');
    copyBtn.addEventListener('mouseout', () => copyBtn.style.opacity = '0.85');

    copyBtn.addEventListener('click', () => {
      const code = figure.querySelector('td.code');
      const text = code ? code.innerText : '';
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.innerHTML = checkIcon;
        setTimeout(() => {
          copyBtn.innerHTML = copyIcon;
        }, 1000);
      });
    });

    figure.style.position = 'relative';
    figure.appendChild(copyBtn);
  });
});
]]></content>
  </entry>
  <entry>
    <title>tag</title>
    <url>/tag/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
